<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SolrHelper.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Aggregate Test Coverage</a> &gt; <a href="index.source.html" class="el_package">org.tailormap.api.solr</a> &gt; <span class="el_source">SolrHelper.java</span></div><h1>SolrHelper.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2024 B3Partners B.V.
 *
 * SPDX-License-Identifier: MIT
 */
package org.tailormap.api.solr;

import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Positive;
import java.io.IOException;
import java.lang.invoke.MethodHandles;
import java.time.Duration;
import java.time.Instant;
import java.time.OffsetDateTime;
import java.time.ZoneId;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.function.Consumer;
import org.apache.solr.client.solrj.SolrClient;
import org.apache.solr.client.solrj.SolrQuery;
import org.apache.solr.client.solrj.SolrResponse;
import org.apache.solr.client.solrj.SolrServerException;
import org.apache.solr.client.solrj.impl.BaseHttpSolrClient;
import org.apache.solr.client.solrj.request.schema.FieldTypeDefinition;
import org.apache.solr.client.solrj.request.schema.SchemaRequest;
import org.apache.solr.client.solrj.response.QueryResponse;
import org.apache.solr.client.solrj.response.UpdateResponse;
import org.apache.solr.client.solrj.response.schema.SchemaResponse;
import org.apache.solr.common.SolrDocumentList;
import org.apache.solr.common.SolrException;
import org.geotools.api.data.Query;
import org.geotools.api.data.SimpleFeatureSource;
import org.geotools.api.feature.simple.SimpleFeature;
import org.geotools.data.simple.SimpleFeatureCollection;
import org.geotools.data.simple.SimpleFeatureIterator;
import org.locationtech.jts.geom.Geometry;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.lang.NonNull;
import org.springframework.lang.Nullable;
import org.tailormap.api.admin.model.TaskProgressEvent;
import org.tailormap.api.geotools.featuresources.FeatureSourceFactoryHelper;
import org.tailormap.api.geotools.processing.GeometryProcessor;
import org.tailormap.api.persistence.SearchIndex;
import org.tailormap.api.persistence.TMFeatureType;
import org.tailormap.api.repository.SearchIndexRepository;
import org.tailormap.api.scheduling.TaskType;
import org.tailormap.api.util.Constants;
import org.tailormap.api.viewer.model.SearchDocument;
import org.tailormap.api.viewer.model.SearchResponse;

/**
 * Solr utility/wrapper class. This class provides methods to add or update a full-text feature type
 * index for a layer, find in the index for a layer, and clear the index for a layer. It also
 * provides a method to close the Solr client as well as automatically closing the client when used
 * in a try-with-resources.
 */
public class SolrHelper implements AutoCloseable, Constants {
<span class="nc" id="L64">  private static final Logger logger =</span>
<span class="nc" id="L65">      LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());</span>

  /** the Solr field type name geometry fields: {@value #SOLR_SPATIAL_FIELDNAME}. */
  private static final String SOLR_SPATIAL_FIELDNAME = &quot;tm_geometry_rpt&quot;;

  private final SolrClient solrClient;

  /** the Solr search field definition requests for Tailormap. */
<span class="nc" id="L73">  private final Map&lt;String, SchemaRequest.AddField&gt; solrSearchFields =</span>
<span class="nc" id="L74">      Map.of(</span>
          SEARCH_LAYER,
              new SchemaRequest.AddField(
<span class="nc" id="L77">                  Map.of(</span>
                      &quot;name&quot;, SEARCH_LAYER,
                      &quot;type&quot;, &quot;string&quot;,
<span class="nc" id="L80">                      &quot;indexed&quot;, true,</span>
<span class="nc" id="L81">                      &quot;stored&quot;, true,</span>
<span class="nc" id="L82">                      &quot;multiValued&quot;, false,</span>
<span class="nc" id="L83">                      &quot;required&quot;, true,</span>
<span class="nc" id="L84">                      &quot;uninvertible&quot;, false)),</span>
          INDEX_GEOM_FIELD,
              new SchemaRequest.AddField(
<span class="nc" id="L87">                  Map.of(&quot;name&quot;, INDEX_GEOM_FIELD, &quot;type&quot;, SOLR_SPATIAL_FIELDNAME, &quot;stored&quot;, true)),</span>
          INDEX_SEARCH_FIELD,
              new SchemaRequest.AddField(
<span class="nc" id="L90">                  Map.of(</span>
                      &quot;name&quot;, INDEX_SEARCH_FIELD,
                      &quot;type&quot;, &quot;text_general&quot;,
<span class="nc" id="L93">                      &quot;indexed&quot;, true,</span>
<span class="nc" id="L94">                      &quot;stored&quot;, true,</span>
<span class="nc" id="L95">                      &quot;multiValued&quot;, true,</span>
<span class="nc" id="L96">                      &quot;required&quot;, true,</span>
<span class="nc" id="L97">                      &quot;uninvertible&quot;, false)),</span>
          INDEX_DISPLAY_FIELD,
              new SchemaRequest.AddField(
<span class="nc" id="L100">                  Map.of(</span>
                      &quot;name&quot;, INDEX_DISPLAY_FIELD,
                      &quot;type&quot;, &quot;text_general&quot;,
<span class="nc" id="L103">                      &quot;indexed&quot;, false,</span>
<span class="nc" id="L104">                      &quot;stored&quot;, true,</span>
<span class="nc" id="L105">                      &quot;multiValued&quot;, true,</span>
<span class="nc" id="L106">                      &quot;required&quot;, true,</span>
<span class="nc" id="L107">                      &quot;uninvertible&quot;, false)));</span>

<span class="nc" id="L109">  private int solrQueryTimeout = 7000;</span>
<span class="nc" id="L110">  private int solrBatchSize = 1000;</span>
<span class="nc" id="L111">  private String solrGeometryValidationRule = &quot;repairBuffer0&quot;;</span>

  /**
   * Create a configured {@code SolrHelper} object.
   *
   * @param solrClient the Solr client, this will be closed when this class is closed
   */
<span class="nc" id="L118">  public SolrHelper(@NotNull SolrClient solrClient) {</span>
<span class="nc" id="L119">    this.solrClient = solrClient;</span>
<span class="nc" id="L120">  }</span>

  /**
   * Configure this {@code SolrHelper} with a query timeout .
   *
   * @param solrQueryTimeout the query timeout in seconds
   */
  public SolrHelper withQueryTimeout(
      @Positive(message = &quot;Must use a positive integer for query timeout&quot;) int solrQueryTimeout) {
<span class="nc" id="L129">    this.solrQueryTimeout = solrQueryTimeout * 1000;</span>
<span class="nc" id="L130">    return this;</span>
  }

  /**
   * Configure this {@code SolrHelper} with a batch size for submitting documents to the Solr
   * instance.
   *
   * @param solrBatchSize the batch size for indexing, must be greater than 0
   */
  public SolrHelper withBatchSize(
      @Positive(message = &quot;Must use a positive integer for batching&quot;) int solrBatchSize) {
<span class="nc" id="L141">    this.solrBatchSize = solrBatchSize;</span>
<span class="nc" id="L142">    return this;</span>
  }

  /**
   * Configure this {@code SolrHelper} to create a geometry field in Solr using the specified
   * validation rule.
   *
   * @see &lt;a
   *     href=&quot;https://locationtech.github.io/spatial4j/apidocs/org/locationtech/spatial4j/context/jts/ValidationRule.html&quot;&gt;ValidationRule&lt;/a&gt;
   * @param solrGeometryValidationRule any of {@code &quot;error&quot;, &quot;none&quot;, &quot;repairBuffer0&quot;,
   *     &quot;repairConvexHull&quot;}
   */
  public SolrHelper withGeometryValidationRule(@NonNull String solrGeometryValidationRule) {
<span class="nc" id="L155">    if (List.of(&quot;error&quot;, &quot;none&quot;, &quot;repairBuffer0&quot;, &quot;repairConvexHull&quot;)</span>
<span class="nc bnc" id="L156" title="All 2 branches missed.">        .contains(solrGeometryValidationRule)) {</span>
<span class="nc" id="L157">      logger.trace(</span>
          &quot;Setting geometry validation rule for Solr geometry field to {}&quot;,
          solrGeometryValidationRule);
<span class="nc" id="L160">      this.solrGeometryValidationRule = solrGeometryValidationRule;</span>
    }
<span class="nc" id="L162">    return this;</span>
  }

  /**
   * Add or update a feature type index for a layer.
   *
   * @param searchIndex the search index config
   * @param tmFeatureType the feature type
   * @param featureSourceFactoryHelper the feature source factory helper
   * @param searchIndexRepository the search index repository, so we can save the {@code
   *     searchIndex}
   * @throws IOException if an I/O error occurs
   * @throws SolrServerException if a Solr error occurs
   * @return the possibly updated {@code searchIndex} object
   */
  @SuppressWarnings(&quot;FromTemporalAccessor&quot;)
  public SearchIndex addFeatureTypeIndex(
      @NotNull SearchIndex searchIndex,
      @NotNull TMFeatureType tmFeatureType,
      @NotNull FeatureSourceFactoryHelper featureSourceFactoryHelper,
      @NotNull SearchIndexRepository searchIndexRepository)
      throws IOException, SolrServerException {
    // use a dummy/logging listener when not given
<span class="nc" id="L185">    Consumer&lt;TaskProgressEvent&gt; progressListener =</span>
        (event) -&gt; {
<span class="nc" id="L187">          logger.debug(&quot;Progress event: {}&quot;, event);</span>
<span class="nc" id="L188">        };</span>

<span class="nc" id="L190">    return this.addFeatureTypeIndex(</span>
        searchIndex,
        tmFeatureType,
        featureSourceFactoryHelper,
        searchIndexRepository,
        progressListener,
        null);
  }

  /**
   * Add or update a feature type index for a layer.
   *
   * @param searchIndex the search index config
   * @param tmFeatureType the feature type
   * @param featureSourceFactoryHelper the feature source factory helper
   * @param searchIndexRepository the search index repository, so we can save the {@code
   *     searchIndex}
   * @param progressListener the progress listener callback
   * @param taskUuid the task UUID, when {@code null} we will attempt to use the UUID from the
   *     {@code searchIndex#getSchedule()}
   * @throws IOException if an I/O error occurs
   * @throws SolrServerException if a Solr error occurs
   * @return the possibly updated {@code searchIndex} object
   */
  @SuppressWarnings(&quot;FromTemporalAccessor&quot;)
  public SearchIndex addFeatureTypeIndex(
      @NotNull SearchIndex searchIndex,
      @NotNull TMFeatureType tmFeatureType,
      @NotNull FeatureSourceFactoryHelper featureSourceFactoryHelper,
      @NotNull SearchIndexRepository searchIndexRepository,
      @NotNull Consumer&lt;TaskProgressEvent&gt; progressListener,
      @Nullable UUID taskUuid)
      throws IOException, SolrServerException {

<span class="nc" id="L224">    createSchemaIfNotExists();</span>

<span class="nc" id="L226">    final Instant startedAt = Instant.now();</span>
<span class="nc" id="L227">    final OffsetDateTime startedAtOffset =</span>
<span class="nc" id="L228">        startedAt.atOffset(ZoneId.systemDefault().getRules().getOffset(startedAt));</span>

<span class="nc bnc" id="L230" title="All 4 branches missed.">    if (null == taskUuid &amp;&amp; null != searchIndex.getSchedule()) {</span>
      // this can be the case when this method is called directly such as when creating
      // the test data. This in itself is not a big problem; it just means that the uuid
      // in any progress events will be null (for that call).
<span class="nc" id="L234">      taskUuid = searchIndex.getSchedule().getUuid();</span>
    }

<span class="nc bnc" id="L237" title="All 2 branches missed.">    if (null == searchIndex.getSearchFieldsUsed()) {</span>
<span class="nc" id="L238">      logger.warn(</span>
<span class="nc" id="L239">          &quot;No search fields configured for search index: {}, bailing out.&quot;, searchIndex.getName());</span>
<span class="nc" id="L240">      return searchIndexRepository.save(</span>
          searchIndex
<span class="nc" id="L242">              .setStatus(SearchIndex.Status.ERROR)</span>
<span class="nc" id="L243">              .setComment(&quot;No search fields configured&quot;));</span>
    }

<span class="nc" id="L246">    progressListener.accept(</span>
        new TaskProgressEvent()
<span class="nc" id="L248">            .type(TaskType.INDEX.getValue())</span>
<span class="nc" id="L249">            .uuid(taskUuid)</span>
<span class="nc" id="L250">            .startedAt(startedAtOffset)</span>
<span class="nc" id="L251">            .progress(0));</span>

    // set fields while filtering out hidden fields
<span class="nc" id="L254">    List&lt;String&gt; searchFields =</span>
<span class="nc" id="L255">        searchIndex.getSearchFieldsUsed().stream()</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">            .filter(s -&gt; !tmFeatureType.getSettings().getHideAttributes().contains(s))</span>
<span class="nc" id="L257">            .toList();</span>
<span class="nc" id="L258">    List&lt;String&gt; displayFields =</span>
<span class="nc" id="L259">        searchIndex.getSearchDisplayFieldsUsed().stream()</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">            .filter(s -&gt; !tmFeatureType.getSettings().getHideAttributes().contains(s))</span>
<span class="nc" id="L261">            .toList();</span>

<span class="nc bnc" id="L263" title="All 2 branches missed.">    if (searchFields.isEmpty()) {</span>
<span class="nc" id="L264">      logger.warn(</span>
          &quot;No valid search fields configured for featuretype: {}, bailing out.&quot;,
<span class="nc" id="L266">          tmFeatureType.getName());</span>
<span class="nc" id="L267">      return searchIndexRepository.save(</span>
          searchIndex
<span class="nc" id="L269">              .setStatus(SearchIndex.Status.ERROR)</span>
<span class="nc" id="L270">              .setComment(&quot;No search fields configured&quot;));</span>
    }

    // add search and display properties to query
<span class="nc" id="L274">    Set&lt;String&gt; propertyNames = new HashSet&lt;&gt;();</span>
    // always add primary key and default geometry to geotools query
<span class="nc" id="L276">    propertyNames.add(tmFeatureType.getPrimaryKeyAttribute());</span>
<span class="nc" id="L277">    propertyNames.add(tmFeatureType.getDefaultGeometryAttribute());</span>
<span class="nc" id="L278">    propertyNames.addAll(searchFields);</span>

<span class="nc bnc" id="L280" title="All 2 branches missed.">    if (!displayFields.isEmpty()) {</span>
<span class="nc" id="L281">      propertyNames.addAll(displayFields);</span>
    }

<span class="nc" id="L284">    clearIndexForLayer(searchIndex.getId());</span>

<span class="nc" id="L286">    logger.info(</span>
        &quot;Indexing started for index id: {}, feature type: {}&quot;,
<span class="nc" id="L288">        searchIndex.getId(),</span>
<span class="nc" id="L289">        tmFeatureType.getName());</span>
<span class="nc" id="L290">    searchIndex = searchIndexRepository.save(searchIndex.setStatus(SearchIndex.Status.INDEXING));</span>

    // collect features to index
<span class="nc" id="L293">    SimpleFeatureSource fs = featureSourceFactoryHelper.openGeoToolsFeatureSource(tmFeatureType);</span>
<span class="nc" id="L294">    Query q = new Query(fs.getName().toString());</span>
    // filter out any hidden properties (there should be none though)
<span class="nc" id="L296">    tmFeatureType.getSettings().getHideAttributes().forEach(propertyNames::remove);</span>
<span class="nc" id="L297">    q.setPropertyNames(List.copyOf(propertyNames));</span>
<span class="nc" id="L298">    q.setStartIndex(0);</span>
    // TODO: make maxFeatures configurable?
    // q.setMaxFeatures(Integer.MAX_VALUE);
<span class="nc" id="L301">    logger.trace(&quot;Indexing query: {}&quot;, q);</span>
<span class="nc" id="L302">    SimpleFeatureCollection simpleFeatureCollection = fs.getFeatures(q);</span>
<span class="nc" id="L303">    final int total = simpleFeatureCollection.size();</span>
<span class="nc" id="L304">    List&lt;FeatureIndexingDocument&gt; docsBatch = new ArrayList&lt;&gt;(solrBatchSize);</span>
    // TODO this does not currently batch/page the feature source query, this doesn't seem to be an
    //   issue for now but could be if the feature source is very, very large or slow
    UpdateResponse updateResponse;
<span class="nc" id="L308">    int indexCounter = 0;</span>
<span class="nc" id="L309">    int indexSkippedCounter = 0;</span>
<span class="nc" id="L310">    try (SimpleFeatureIterator iterator = simpleFeatureCollection.features()) {</span>
<span class="nc bnc" id="L311" title="All 2 branches missed.">      while (iterator.hasNext()) {</span>
<span class="nc" id="L312">        indexCounter++;</span>
<span class="nc" id="L313">        SimpleFeature feature = iterator.next();</span>
        // note that this will create a unique document
<span class="nc" id="L315">        FeatureIndexingDocument doc =</span>
<span class="nc" id="L316">            new FeatureIndexingDocument(feature.getID(), searchIndex.getId());</span>
<span class="nc" id="L317">        List&lt;String&gt; searchValues = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L318">        List&lt;String&gt; displayValues = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L319">        propertyNames.forEach(</span>
            propertyName -&gt; {
<span class="nc" id="L321">              Object value = feature.getAttribute(propertyName);</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">              if (value != null) {</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">                if (value instanceof Geometry</span>
<span class="nc bnc" id="L324" title="All 2 branches missed.">                    &amp;&amp; propertyName.equals(tmFeatureType.getDefaultGeometryAttribute())) {</span>
                  // We could use GeoJSON, but WKT is more compact and that would also incur a
                  // change to the API
<span class="nc" id="L327">                  doc.setGeometry(GeometryProcessor.processGeometry(value, true, true, null));</span>
                } else {
<span class="nc bnc" id="L329" title="All 2 branches missed.">                  if (searchFields.contains(propertyName)) {</span>
<span class="nc" id="L330">                    searchValues.add(value.toString());</span>
                  }
<span class="nc bnc" id="L332" title="All 2 branches missed.">                  if (displayFields.contains(propertyName)) {</span>
<span class="nc" id="L333">                    displayValues.add(value.toString());</span>
                  }
                }
              }
<span class="nc" id="L337">            });</span>
<span class="nc bnc" id="L338" title="All 4 branches missed.">        if (searchValues.isEmpty() || displayValues.isEmpty()) {</span>
          // this is a record/document that can either not be found or not be displayed
<span class="nc" id="L340">          logger.trace(</span>
              &quot;No search or display values found for feature: {} in featuretype: {}, skipped for indexing&quot;,
<span class="nc" id="L342">              feature.getID(),</span>
<span class="nc" id="L343">              tmFeatureType.getName());</span>
<span class="nc" id="L344">          indexSkippedCounter++;</span>
        } else {
<span class="nc" id="L346">          doc.setSearchFields(searchValues.toArray(new String[0]));</span>
<span class="nc" id="L347">          doc.setDisplayFields(displayValues.toArray(new String[0]));</span>
<span class="nc" id="L348">          docsBatch.add(doc);</span>
        }

<span class="nc bnc" id="L351" title="All 2 branches missed.">        if (indexCounter % solrBatchSize == 0) {</span>
<span class="nc" id="L352">          updateResponse = solrClient.addBeans(docsBatch, solrQueryTimeout);</span>
<span class="nc" id="L353">          logger.info(</span>
              &quot;Added {} documents of {} to index, result status: {}&quot;,
<span class="nc" id="L355">              indexCounter - indexSkippedCounter,</span>
<span class="nc" id="L356">              total,</span>
<span class="nc" id="L357">              updateResponse.getStatus());</span>
<span class="nc" id="L358">          progressListener.accept(</span>
              new TaskProgressEvent()
<span class="nc" id="L360">                  .type(TaskType.INDEX.getValue())</span>
<span class="nc" id="L361">                  .uuid(taskUuid)</span>
<span class="nc" id="L362">                  .startedAt(startedAtOffset)</span>
<span class="nc" id="L363">                  .progress((indexCounter - indexSkippedCounter))</span>
<span class="nc" id="L364">                  .total(total));</span>
<span class="nc" id="L365">          docsBatch.clear();</span>
        }
<span class="nc" id="L367">      }</span>
    } finally {
<span class="nc bnc" id="L369" title="All 2 branches missed.">      if (fs.getDataStore() != null) fs.getDataStore().dispose();</span>
    }

<span class="nc bnc" id="L372" title="All 2 branches missed.">    if (!docsBatch.isEmpty()) {</span>
<span class="nc" id="L373">      solrClient.addBeans(docsBatch, solrQueryTimeout);</span>
<span class="nc" id="L374">      logger.info(&quot;Added last {} documents of {} to index&quot;, docsBatch.size(), total);</span>
<span class="nc" id="L375">      progressListener.accept(</span>
          new TaskProgressEvent()
<span class="nc" id="L377">              .type(TaskType.INDEX.getValue())</span>
<span class="nc" id="L378">              .uuid(taskUuid)</span>
<span class="nc" id="L379">              .startedAt(startedAtOffset)</span>
<span class="nc" id="L380">              .progress((indexCounter - indexSkippedCounter))</span>
<span class="nc" id="L381">              .total(total));</span>
    }
<span class="nc" id="L383">    final Instant finishedAt = Instant.now();</span>
<span class="nc" id="L384">    final OffsetDateTime finishedAtOffset =</span>
<span class="nc" id="L385">        finishedAt.atOffset(ZoneId.systemDefault().getRules().getOffset(finishedAt));</span>
<span class="nc" id="L386">    Duration processTime = Duration.between(startedAt, finishedAt).abs();</span>
<span class="nc" id="L387">    logger.info(</span>
        &quot;Indexing finished for index id: {}, featuretype: {} at {} in {}&quot;,
<span class="nc" id="L389">        searchIndex.getId(),</span>
<span class="nc" id="L390">        tmFeatureType.getName(),</span>
        finishedAtOffset,
        processTime);
<span class="nc" id="L393">    updateResponse = this.solrClient.commit();</span>
<span class="nc" id="L394">    logger.debug(&quot;Update response commit status: {}&quot;, updateResponse.getStatus());</span>

<span class="nc bnc" id="L396" title="All 2 branches missed.">    if (indexSkippedCounter &gt; 0) {</span>
<span class="nc" id="L397">      logger.warn(</span>
          &quot;{} features were skipped because no search or display values were found.&quot;,
<span class="nc" id="L399">          indexSkippedCounter);</span>
<span class="nc" id="L400">      searchIndex =</span>
<span class="nc" id="L401">          searchIndex.setComment(</span>
              &quot;Indexed %s features in %s.%s seconds, started at %s. %s features were skipped because no search or display values were found.&quot;
<span class="nc" id="L403">                  .formatted(</span>
<span class="nc" id="L404">                      total,</span>
<span class="nc" id="L405">                      processTime.getSeconds(),</span>
<span class="nc" id="L406">                      processTime.getNano(),</span>
<span class="nc" id="L407">                      startedAt.atOffset(ZoneId.systemDefault().getRules().getOffset(startedAt)),</span>
<span class="nc" id="L408">                      indexSkippedCounter));</span>
    } else {
<span class="nc" id="L410">      searchIndex =</span>
<span class="nc" id="L411">          searchIndex.setComment(</span>
              &quot;Indexed %s features in %s.%s seconds, started at %s.&quot;
<span class="nc" id="L413">                  .formatted(</span>
<span class="nc" id="L414">                      total,</span>
<span class="nc" id="L415">                      processTime.getSeconds(),</span>
<span class="nc" id="L416">                      processTime.getNano(),</span>
<span class="nc" id="L417">                      startedAt.atOffset(ZoneId.systemDefault().getRules().getOffset(startedAt))));</span>
    }

<span class="nc" id="L420">    return searchIndexRepository.save(</span>
<span class="nc" id="L421">        searchIndex.setLastIndexed(finishedAtOffset).setStatus(SearchIndex.Status.INDEXED));</span>
  }

  /**
   * Clear the index for a layer.
   *
   * @param searchLayerId the layer id
   * @throws IOException if an I/O error occurs
   * @throws SolrServerException if a Solr error occurs
   */
  public void clearIndexForLayer(@NotNull Long searchLayerId)
      throws IOException, SolrServerException {

<span class="nc" id="L434">    QueryResponse response =</span>
<span class="nc" id="L435">        solrClient.query(</span>
            new SolrQuery(&quot;exists(query(&quot; + SEARCH_LAYER + &quot;:&quot; + searchLayerId + &quot;))&quot;));
<span class="nc bnc" id="L437" title="All 2 branches missed.">    if (response.getResults().getNumFound() &gt; 0) {</span>
<span class="nc" id="L438">      logger.info(&quot;Clearing index for searchLayer {}&quot;, searchLayerId);</span>
<span class="nc" id="L439">      UpdateResponse updateResponse = solrClient.deleteByQuery(SEARCH_LAYER + &quot;:&quot; + searchLayerId);</span>
<span class="nc" id="L440">      logger.debug(&quot;Delete response status: {}&quot;, updateResponse.getStatus());</span>
<span class="nc" id="L441">      updateResponse = solrClient.commit();</span>
<span class="nc" id="L442">      logger.debug(&quot;Commit response status: {}&quot;, updateResponse.getStatus());</span>
<span class="nc" id="L443">    } else {</span>
<span class="nc" id="L444">      logger.info(&quot;No index to clear for layer {}&quot;, searchLayerId);</span>
    }
<span class="nc" id="L446">  }</span>

  /**
   * Search in the index for a layer. The given query is augmented to filter on the {@code
   * solrLayerId}.
   *
   * @param searchIndex the search index
   * @param solrQuery the query, when {@code null} or empty, the query is set to {@code *} (match
   *     all)
   * @param solrPoint the point to search around, in (x y) format
   * @param solrDistance the distance to search around the point in Solr distance units (kilometers)
   * @param start the start index, starting at 0
   * @param numResultsToReturn the number of results to return
   * @return the documents
   * @throws IOException if an I/O error occurs
   * @throws SolrServerException if a Solr error occurs
   */
  public SearchResponse findInIndex(
      @NotNull SearchIndex searchIndex,
      String solrQuery,
      String solrFilterQuery,
      String solrPoint,
      Double solrDistance,
      int start,
      int numResultsToReturn)
      throws IOException, SolrServerException, SolrException {

<span class="nc" id="L473">    logger.info(&quot;Find in index for {}&quot;, searchIndex.getId());</span>
<span class="nc bnc" id="L474" title="All 4 branches missed.">    if (null == solrQuery || solrQuery.isBlank()) {</span>
<span class="nc" id="L475">      solrQuery = &quot;*&quot;;</span>
    }
    // TODO We could escape special/syntax characters, but that also prevents using
    //      keys like ~ and *
    // solrQuery = ClientUtils.escapeQueryChars(solrQuery);

<span class="nc" id="L481">    final SolrQuery query =</span>
        new SolrQuery(INDEX_SEARCH_FIELD + &quot;:&quot; + solrQuery)
<span class="nc" id="L483">            .setShowDebugInfo(logger.isDebugEnabled())</span>
<span class="nc" id="L484">            .setTimeAllowed(solrQueryTimeout)</span>
<span class="nc" id="L485">            .setIncludeScore(true)</span>
<span class="nc" id="L486">            .setFields(SEARCH_ID_FIELD, INDEX_DISPLAY_FIELD, INDEX_GEOM_FIELD)</span>
<span class="nc" id="L487">            .addFilterQuery(SEARCH_LAYER + &quot;:&quot; + searchIndex.getId())</span>
<span class="nc" id="L488">            .setSort(&quot;score&quot;, SolrQuery.ORDER.desc)</span>
<span class="nc" id="L489">            .addSort(SEARCH_ID_FIELD, SolrQuery.ORDER.asc)</span>
<span class="nc" id="L490">            .setRows(numResultsToReturn)</span>
<span class="nc" id="L491">            .setStart(start);</span>

<span class="nc bnc" id="L493" title="All 4 branches missed.">    if (null != solrFilterQuery &amp;&amp; !solrFilterQuery.isBlank()) {</span>
<span class="nc" id="L494">      query.addFilterQuery(solrFilterQuery);</span>
    }
<span class="nc bnc" id="L496" title="All 4 branches missed.">    if (null != solrPoint &amp;&amp; null != solrDistance) {</span>
<span class="nc bnc" id="L497" title="All 2 branches missed.">      if (null == solrFilterQuery</span>
<span class="nc bnc" id="L498" title="All 4 branches missed.">          || !(solrFilterQuery.startsWith(&quot;{!geofilt&quot;) || solrFilterQuery.startsWith(&quot;{!bbox&quot;))) {</span>
<span class="nc" id="L499">        query.addFilterQuery(&quot;{!geofilt sfield=&quot; + INDEX_GEOM_FIELD + &quot;}&quot;);</span>
      }
<span class="nc" id="L501">      query.add(&quot;pt&quot;, solrPoint);</span>
<span class="nc" id="L502">      query.add(&quot;d&quot;, solrDistance.toString());</span>
    }
<span class="nc" id="L504">    query.set(&quot;q.op&quot;, &quot;AND&quot;);</span>
<span class="nc" id="L505">    logger.debug(&quot;Solr query: {}&quot;, query);</span>

<span class="nc" id="L507">    final QueryResponse response = solrClient.query(query);</span>
<span class="nc" id="L508">    logger.debug(&quot;response: {}&quot;, response);</span>

<span class="nc" id="L510">    final SolrDocumentList solrDocumentList = response.getResults();</span>
<span class="nc" id="L511">    logger.debug(&quot;Found {} solr documents&quot;, solrDocumentList.getNumFound());</span>
<span class="nc" id="L512">    final SearchResponse searchResponse =</span>
        new SearchResponse()
<span class="nc" id="L514">            .total(solrDocumentList.getNumFound())</span>
<span class="nc" id="L515">            .start(response.getResults().getStart())</span>
<span class="nc" id="L516">            .maxScore(solrDocumentList.getMaxScore());</span>
<span class="nc" id="L517">    response</span>
<span class="nc" id="L518">        .getResults()</span>
<span class="nc" id="L519">        .forEach(</span>
            solrDocument -&gt; {
<span class="nc" id="L521">              List&lt;String&gt; displayValues =</span>
<span class="nc" id="L522">                  solrDocument.getFieldValues(INDEX_DISPLAY_FIELD).stream()</span>
<span class="nc" id="L523">                      .map(Object::toString)</span>
<span class="nc" id="L524">                      .toList();</span>
<span class="nc" id="L525">              searchResponse.addDocumentsItem(</span>
                  new SearchDocument()
<span class="nc" id="L527">                      .fid(solrDocument.getFieldValue(SEARCH_ID_FIELD).toString())</span>
<span class="nc" id="L528">                      .geometry(solrDocument.getFieldValue(INDEX_GEOM_FIELD).toString())</span>
<span class="nc" id="L529">                      .displayValues(displayValues));</span>
<span class="nc" id="L530">            });</span>

<span class="nc" id="L532">    return searchResponse;</span>
  }

  /**
   * Close the wrapped Solr client.
   *
   * @throws IOException if an I/O error occurs
   */
  @Override
  public void close() throws IOException {
<span class="nc bnc" id="L542" title="All 2 branches missed.">    if (null != this.solrClient) this.solrClient.close();</span>
<span class="nc" id="L543">  }</span>

  private boolean checkSchemaIfFieldExists(String fieldName) {
<span class="nc" id="L546">    SchemaRequest.Field fieldCheck = new SchemaRequest.Field(fieldName);</span>
    try {
<span class="nc" id="L548">      SchemaResponse.FieldResponse isField = fieldCheck.process(solrClient);</span>
<span class="nc" id="L549">      logger.debug(&quot;Field {} exists&quot;, isField.getField());</span>
<span class="nc" id="L550">      return true;</span>
<span class="nc" id="L551">    } catch (SolrServerException | BaseHttpSolrClient.RemoteSolrException e) {</span>
<span class="nc" id="L552">      logger.debug(</span>
          &quot;Field {} does not exist or could not be retrieved. Assuming it does not exist.&quot;,
          fieldName);
<span class="nc" id="L555">    } catch (IOException e) {</span>
<span class="nc" id="L556">      logger.error(&quot;Tried getting field: {}, but failed.&quot;, fieldName, e);</span>
<span class="nc" id="L557">    }</span>
<span class="nc" id="L558">    return false;</span>
  }

  /**
   * @param fieldName the name of the field to create
   * @throws SolrServerException if a Solr error occurs
   * @throws IOException if an I/O error occurs
   */
  private void createSchemaFieldIfNotExists(String fieldName)
      throws SolrServerException, IOException {
<span class="nc bnc" id="L568" title="All 2 branches missed.">    if (!checkSchemaIfFieldExists(fieldName)) {</span>
<span class="nc" id="L569">      logger.info(&quot;Creating Solr field {}.&quot;, fieldName);</span>
<span class="nc" id="L570">      SchemaRequest.AddField schemaRequest = solrSearchFields.get(fieldName);</span>
<span class="nc" id="L571">      SolrResponse response = schemaRequest.process(solrClient);</span>
<span class="nc" id="L572">      logger.debug(&quot;Field type {} created&quot;, response);</span>
<span class="nc" id="L573">      solrClient.commit();</span>
    }
<span class="nc" id="L575">  }</span>

  /** Programmatically create the schema if it does not exist. */
  private void createSchemaIfNotExists() {
<span class="nc" id="L579">    solrSearchFields.forEach(</span>
        (key, value) -&gt; {
          try {
<span class="nc bnc" id="L582" title="All 2 branches missed.">            if (key.equals(INDEX_GEOM_FIELD)) {</span>
<span class="nc" id="L583">              createGeometryFieldTypeIfNotExists();</span>
            }
<span class="nc" id="L585">            createSchemaFieldIfNotExists(key);</span>
<span class="nc" id="L586">          } catch (SolrServerException | IOException e) {</span>
<span class="nc" id="L587">            logger.error(</span>
                &quot;Error creating schema field: {} indexing may fail. Details: {}&quot;,
                key,
<span class="nc" id="L590">                e.getLocalizedMessage(),</span>
                e);
<span class="nc" id="L592">          }</span>
<span class="nc" id="L593">        });</span>
<span class="nc" id="L594">  }</span>

  private void createGeometryFieldTypeIfNotExists() throws SolrServerException, IOException {
<span class="nc" id="L597">    SchemaRequest.FieldType fieldTypeCheck = new SchemaRequest.FieldType(SOLR_SPATIAL_FIELDNAME);</span>
    try {
<span class="nc" id="L599">      SchemaResponse.FieldTypeResponse isFieldType = fieldTypeCheck.process(solrClient);</span>
<span class="nc" id="L600">      logger.debug(&quot;Field type {} exists&quot;, isFieldType.getFieldType());</span>
<span class="nc" id="L601">      return;</span>
<span class="nc" id="L602">    } catch (SolrServerException | BaseHttpSolrClient.RemoteSolrException e) {</span>
<span class="nc" id="L603">      logger.debug(</span>
          &quot;Field type {} does not exist or could not be retrieved. Assuming it does not exist.&quot;,
          SOLR_SPATIAL_FIELDNAME);
<span class="nc" id="L606">    } catch (IOException e) {</span>
<span class="nc" id="L607">      logger.error(&quot;Tried getting field type: {}, but failed.&quot;, SOLR_SPATIAL_FIELDNAME, e);</span>
<span class="nc" id="L608">    }</span>

<span class="nc" id="L610">    logger.info(</span>
        &quot;Creating Solr field type for {} with validation rule {}&quot;,
        SOLR_SPATIAL_FIELDNAME,
        solrGeometryValidationRule);
<span class="nc" id="L614">    FieldTypeDefinition spatialFieldTypeDef = new FieldTypeDefinition();</span>
<span class="nc" id="L615">    Map&lt;String, Object&gt; spatialFieldAttributes =</span>
        new HashMap&lt;&gt;(
<span class="nc" id="L617">            Map.of(</span>
                &quot;name&quot;, SOLR_SPATIAL_FIELDNAME,
                &quot;class&quot;, &quot;solr.SpatialRecursivePrefixTreeFieldType&quot;,
                &quot;spatialContextFactory&quot;, &quot;JTS&quot;,
<span class="nc" id="L621">                &quot;geo&quot;, false,</span>
                &quot;distanceUnits&quot;, &quot;kilometers&quot;,
                &quot;distCalculator&quot;, &quot;cartesian&quot;,
                &quot;format&quot;, &quot;WKT&quot;,
<span class="nc" id="L625">                &quot;autoIndex&quot;, true,</span>
                &quot;distErrPct&quot;, &quot;0.025&quot;,
                &quot;maxDistErr&quot;, &quot;0.001&quot;));
<span class="nc" id="L628">    spatialFieldAttributes.putAll(</span>
<span class="nc" id="L629">        Map.of(</span>
            &quot;prefixTree&quot;,
            &quot;packedQuad&quot;,
            // see
            // https://locationtech.github.io/spatial4j/apidocs/org/locationtech/spatial4j/context/jts/ValidationRule.html
            &quot;validationRule&quot;,
            this.solrGeometryValidationRule,
            // NOTE THE ODDITY in coordinate order of &quot;worldBounds&quot;,
            // &quot;ENVELOPE(minX, maxX, maxY, minY)&quot;
            &quot;worldBounds&quot;,
            // webmercator / EPSG:3857 projected bounds
            &quot;ENVELOPE(-20037508.34, 20037508.34, 20048966.1, -20048966.1)&quot;
            // Amersfoort/RD new / EPSG:28992 projected bounds
            // &quot;ENVELOPE(482.06, 284182.97, 637049.52, 306602.42)&quot;
            ));
<span class="nc" id="L644">    spatialFieldTypeDef.setAttributes(spatialFieldAttributes);</span>
<span class="nc" id="L645">    SchemaRequest.AddFieldType spatialFieldType =</span>
        new SchemaRequest.AddFieldType(spatialFieldTypeDef);
<span class="nc" id="L647">    spatialFieldType.process(solrClient);</span>
<span class="nc" id="L648">    solrClient.commit();</span>
<span class="nc" id="L649">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>