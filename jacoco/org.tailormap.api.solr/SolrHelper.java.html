<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SolrHelper.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Aggregate Test Coverage</a> &gt; <a href="index.source.html" class="el_package">org.tailormap.api.solr</a> &gt; <span class="el_source">SolrHelper.java</span></div><h1>SolrHelper.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2024 B3Partners B.V.
 *
 * SPDX-License-Identifier: MIT
 */
package org.tailormap.api.solr;

import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Positive;
import java.io.IOException;
import java.lang.invoke.MethodHandles;
import java.time.Duration;
import java.time.Instant;
import java.time.ZoneId;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.apache.solr.client.solrj.SolrClient;
import org.apache.solr.client.solrj.SolrQuery;
import org.apache.solr.client.solrj.SolrResponse;
import org.apache.solr.client.solrj.SolrServerException;
import org.apache.solr.client.solrj.impl.BaseHttpSolrClient;
import org.apache.solr.client.solrj.request.schema.FieldTypeDefinition;
import org.apache.solr.client.solrj.request.schema.SchemaRequest;
import org.apache.solr.client.solrj.response.QueryResponse;
import org.apache.solr.client.solrj.response.UpdateResponse;
import org.apache.solr.client.solrj.response.schema.SchemaResponse;
import org.apache.solr.common.SolrDocumentList;
import org.apache.solr.common.SolrException;
import org.geotools.api.data.Query;
import org.geotools.api.data.SimpleFeatureSource;
import org.geotools.api.feature.simple.SimpleFeature;
import org.geotools.data.simple.SimpleFeatureCollection;
import org.geotools.data.simple.SimpleFeatureIterator;
import org.locationtech.jts.geom.Geometry;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.lang.NonNull;
import org.tailormap.api.geotools.featuresources.FeatureSourceFactoryHelper;
import org.tailormap.api.geotools.processing.GeometryProcessor;
import org.tailormap.api.persistence.SearchIndex;
import org.tailormap.api.persistence.TMFeatureType;
import org.tailormap.api.repository.SearchIndexRepository;
import org.tailormap.api.util.Constants;
import org.tailormap.api.viewer.model.SearchDocument;
import org.tailormap.api.viewer.model.SearchResponse;

/**
 * Solr utility/wrapper class. This class provides methods to add or update a full-text feature type
 * index for a layer, find in the index for a layer, and clear the index for a layer. It also
 * provides a method to close the Solr client as well as automatically closing the client when used
 * in a try-with-resources.
 */
public class SolrHelper implements AutoCloseable, Constants {
<span class="nc" id="L58">  private static final Logger logger =</span>
<span class="nc" id="L59">      LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());</span>

  /** the Solr field type name geometry fields: {@value #SOLR_SPATIAL_FIELDNAME}. */
  private static final String SOLR_SPATIAL_FIELDNAME = &quot;tm_geometry_rpt&quot;;

  private final SolrClient solrClient;

  /** the Solr search field definition requests for Tailormap. */
<span class="nc" id="L67">  private final Map&lt;String, SchemaRequest.AddField&gt; solrSearchFields =</span>
<span class="nc" id="L68">      Map.of(</span>
          SEARCH_LAYER,
              new SchemaRequest.AddField(
<span class="nc" id="L71">                  Map.of(</span>
                      &quot;name&quot;, SEARCH_LAYER,
                      &quot;type&quot;, &quot;string&quot;,
<span class="nc" id="L74">                      &quot;indexed&quot;, true,</span>
<span class="nc" id="L75">                      &quot;stored&quot;, true,</span>
<span class="nc" id="L76">                      &quot;multiValued&quot;, false,</span>
<span class="nc" id="L77">                      &quot;required&quot;, true,</span>
<span class="nc" id="L78">                      &quot;uninvertible&quot;, false)),</span>
          INDEX_GEOM_FIELD,
              new SchemaRequest.AddField(
<span class="nc" id="L81">                  Map.of(&quot;name&quot;, INDEX_GEOM_FIELD, &quot;type&quot;, SOLR_SPATIAL_FIELDNAME, &quot;stored&quot;, true)),</span>
          INDEX_SEARCH_FIELD,
              new SchemaRequest.AddField(
<span class="nc" id="L84">                  Map.of(</span>
                      &quot;name&quot;, INDEX_SEARCH_FIELD,
                      &quot;type&quot;, &quot;text_general&quot;,
<span class="nc" id="L87">                      &quot;indexed&quot;, true,</span>
<span class="nc" id="L88">                      &quot;stored&quot;, true,</span>
<span class="nc" id="L89">                      &quot;multiValued&quot;, true,</span>
<span class="nc" id="L90">                      &quot;required&quot;, true,</span>
<span class="nc" id="L91">                      &quot;uninvertible&quot;, false)),</span>
          INDEX_DISPLAY_FIELD,
              new SchemaRequest.AddField(
<span class="nc" id="L94">                  Map.of(</span>
                      &quot;name&quot;, INDEX_DISPLAY_FIELD,
                      &quot;type&quot;, &quot;text_general&quot;,
<span class="nc" id="L97">                      &quot;indexed&quot;, false,</span>
<span class="nc" id="L98">                      &quot;stored&quot;, true,</span>
<span class="nc" id="L99">                      &quot;multiValued&quot;, true,</span>
<span class="nc" id="L100">                      &quot;required&quot;, true,</span>
<span class="nc" id="L101">                      &quot;uninvertible&quot;, false)));</span>

<span class="nc" id="L103">  private int solrQueryTimeout = 7000;</span>
<span class="nc" id="L104">  private int solrBatchSize = 1000;</span>
<span class="nc" id="L105">  private String solrGeometryValidationRule = &quot;repairBuffer0&quot;;</span>

  /**
   * Create a configured {@code SolrHelper} object.
   *
   * @param solrClient the Solr client, this will be closed when this class is closed
   */
<span class="nc" id="L112">  public SolrHelper(@NotNull SolrClient solrClient) {</span>
<span class="nc" id="L113">    this.solrClient = solrClient;</span>
<span class="nc" id="L114">  }</span>

  /**
   * Configure this {@code SolrHelper} with a query timeout .
   *
   * @param solrQueryTimeout the query timeout in seconds
   */
  public SolrHelper withQueryTimeout(
      @Positive(message = &quot;Must use a positive integer for query timeout&quot;) int solrQueryTimeout) {
<span class="nc" id="L123">    this.solrQueryTimeout = solrQueryTimeout * 1000;</span>
<span class="nc" id="L124">    return this;</span>
  }

  /**
   * Configure this {@code SolrHelper} with a batch size for submitting documents to the Solr
   * instance.
   *
   * @param solrBatchSize the batch size for indexing, must be greater than 0
   */
  public SolrHelper withBatchSize(
      @Positive(message = &quot;Must use a positive integer for batching&quot;) int solrBatchSize) {
<span class="nc" id="L135">    this.solrBatchSize = solrBatchSize;</span>
<span class="nc" id="L136">    return this;</span>
  }

  /**
   * Configure this {@code SolrHelper} to create a geometry field in Solr using the specified
   * validation rule.
   *
   * @see &lt;a
   *     href=&quot;https://locationtech.github.io/spatial4j/apidocs/org/locationtech/spatial4j/context/jts/ValidationRule.html&quot;&gt;ValidationRule&lt;/a&gt;
   * @param solrGeometryValidationRule any of {@code &quot;error&quot;, &quot;none&quot;, &quot;repairBuffer0&quot;,
   *     &quot;repairConvexHull&quot;}
   */
  public SolrHelper withGeometryValidationRule(@NonNull String solrGeometryValidationRule) {
<span class="nc" id="L149">    if (List.of(&quot;error&quot;, &quot;none&quot;, &quot;repairBuffer0&quot;, &quot;repairConvexHull&quot;)</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">        .contains(solrGeometryValidationRule)) {</span>
<span class="nc" id="L151">      logger.trace(</span>
          &quot;Setting geometry validation rule for Solr geometry field to {}&quot;,
          solrGeometryValidationRule);
<span class="nc" id="L154">      this.solrGeometryValidationRule = solrGeometryValidationRule;</span>
    }
<span class="nc" id="L156">    return this;</span>
  }

  /**
   * Add or update a feature type index for a layer.
   *
   * @param searchIndex the search index config
   * @param tmFeatureType the feature type
   * @param featureSourceFactoryHelper the feature source factory helper
   * @param searchIndexRepository the search index repository, so we can save the {@code
   *     searchIndex}
   * @throws IOException if an I/O error occurs
   * @throws SolrServerException if a Solr error occurs
   * @return the possibly updated {@code searchIndex} object
   */
  @SuppressWarnings(&quot;FromTemporalAccessor&quot;)
  public SearchIndex addFeatureTypeIndex(
      @NotNull SearchIndex searchIndex,
      @NotNull TMFeatureType tmFeatureType,
      @NotNull FeatureSourceFactoryHelper featureSourceFactoryHelper,
      @NotNull SearchIndexRepository searchIndexRepository)
      throws IOException, SolrServerException {

<span class="nc" id="L179">    createSchemaIfNotExists();</span>

<span class="nc" id="L181">    final Instant startedAt = Instant.now();</span>

<span class="nc bnc" id="L183" title="All 2 branches missed.">    if (null == searchIndex.getSearchFieldsUsed()) {</span>
<span class="nc" id="L184">      logger.warn(</span>
<span class="nc" id="L185">          &quot;No search fields configured for search index: {}, bailing out.&quot;, searchIndex.getName());</span>
<span class="nc" id="L186">      return searchIndexRepository.save(</span>
          searchIndex
<span class="nc" id="L188">              .setStatus(SearchIndex.Status.ERROR)</span>
<span class="nc" id="L189">              .setComment(&quot;No search fields configured&quot;));</span>
    }

    // set fields while filtering out hidden fields
<span class="nc" id="L193">    List&lt;String&gt; searchFields =</span>
<span class="nc" id="L194">        searchIndex.getSearchFieldsUsed().stream()</span>
<span class="nc bnc" id="L195" title="All 2 branches missed.">            .filter(s -&gt; !tmFeatureType.getSettings().getHideAttributes().contains(s))</span>
<span class="nc" id="L196">            .toList();</span>
<span class="nc" id="L197">    List&lt;String&gt; displayFields =</span>
<span class="nc" id="L198">        searchIndex.getSearchDisplayFieldsUsed().stream()</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">            .filter(s -&gt; !tmFeatureType.getSettings().getHideAttributes().contains(s))</span>
<span class="nc" id="L200">            .toList();</span>

<span class="nc bnc" id="L202" title="All 2 branches missed.">    if (searchFields.isEmpty()) {</span>
<span class="nc" id="L203">      logger.warn(</span>
          &quot;No valid search fields configured for featuretype: {}, bailing out.&quot;,
<span class="nc" id="L205">          tmFeatureType.getName());</span>
<span class="nc" id="L206">      return searchIndexRepository.save(</span>
          searchIndex
<span class="nc" id="L208">              .setStatus(SearchIndex.Status.ERROR)</span>
<span class="nc" id="L209">              .setComment(&quot;No search fields configured&quot;));</span>
    }

    // add search and display properties to query
<span class="nc" id="L213">    Set&lt;String&gt; propertyNames = new HashSet&lt;&gt;();</span>
    // always add primary key and default geometry to geotools query
<span class="nc" id="L215">    propertyNames.add(tmFeatureType.getPrimaryKeyAttribute());</span>
<span class="nc" id="L216">    propertyNames.add(tmFeatureType.getDefaultGeometryAttribute());</span>
<span class="nc" id="L217">    propertyNames.addAll(searchFields);</span>

<span class="nc bnc" id="L219" title="All 2 branches missed.">    if (!displayFields.isEmpty()) {</span>
<span class="nc" id="L220">      propertyNames.addAll(displayFields);</span>
    }

<span class="nc" id="L223">    clearIndexForLayer(searchIndex.getId());</span>

<span class="nc" id="L225">    logger.info(</span>
        &quot;Indexing started for index id: {}, feature type: {}&quot;,
<span class="nc" id="L227">        searchIndex.getId(),</span>
<span class="nc" id="L228">        tmFeatureType.getName());</span>
<span class="nc" id="L229">    searchIndex = searchIndexRepository.save(searchIndex.setStatus(SearchIndex.Status.INDEXING));</span>

    // collect features to index
<span class="nc" id="L232">    SimpleFeatureSource fs = featureSourceFactoryHelper.openGeoToolsFeatureSource(tmFeatureType);</span>
<span class="nc" id="L233">    Query q = new Query(fs.getName().toString());</span>
    // filter out any hidden properties (there should be none though)
<span class="nc" id="L235">    tmFeatureType.getSettings().getHideAttributes().forEach(propertyNames::remove);</span>
<span class="nc" id="L236">    q.setPropertyNames(List.copyOf(propertyNames));</span>
<span class="nc" id="L237">    q.setStartIndex(0);</span>
    // TODO: make maxFeatures configurable?
    // q.setMaxFeatures(Integer.MAX_VALUE);
<span class="nc" id="L240">    logger.trace(&quot;Indexing query: {}&quot;, q);</span>
<span class="nc" id="L241">    SimpleFeatureCollection simpleFeatureCollection = fs.getFeatures(q);</span>
<span class="nc" id="L242">    final int total = simpleFeatureCollection.size();</span>
<span class="nc" id="L243">    List&lt;FeatureIndexingDocument&gt; docsBatch = new ArrayList&lt;&gt;(solrBatchSize);</span>
    // TODO this does not currently batch/page the feature source query, this doesn't seem to be an
    //   issue for now but could be if the feature source is very, very large or slow
    UpdateResponse updateResponse;
<span class="nc" id="L247">    int indexCounter = 0;</span>
<span class="nc" id="L248">    int indexSkippedCounter = 0;</span>
<span class="nc" id="L249">    try (SimpleFeatureIterator iterator = simpleFeatureCollection.features()) {</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">      while (iterator.hasNext()) {</span>
<span class="nc" id="L251">        indexCounter++;</span>
<span class="nc" id="L252">        SimpleFeature feature = iterator.next();</span>
        // note that this will create a unique document
<span class="nc" id="L254">        FeatureIndexingDocument doc =</span>
<span class="nc" id="L255">            new FeatureIndexingDocument(feature.getID(), searchIndex.getId());</span>
<span class="nc" id="L256">        List&lt;String&gt; searchValues = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L257">        List&lt;String&gt; displayValues = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L258">        propertyNames.forEach(</span>
            propertyName -&gt; {
<span class="nc" id="L260">              Object value = feature.getAttribute(propertyName);</span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">              if (value != null) {</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">                if (value instanceof Geometry</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">                    &amp;&amp; propertyName.equals(tmFeatureType.getDefaultGeometryAttribute())) {</span>
                  // We could use GeoJSON, but WKT is more compact and that would also incur a
                  // change to the API
<span class="nc" id="L266">                  doc.setGeometry(GeometryProcessor.processGeometry(value, true, true, null));</span>
                } else {
<span class="nc bnc" id="L268" title="All 2 branches missed.">                  if (searchFields.contains(propertyName)) {</span>
<span class="nc" id="L269">                    searchValues.add(value.toString());</span>
                  }
<span class="nc bnc" id="L271" title="All 2 branches missed.">                  if (displayFields.contains(propertyName)) {</span>
<span class="nc" id="L272">                    displayValues.add(value.toString());</span>
                  }
                }
              }
<span class="nc" id="L276">            });</span>
<span class="nc bnc" id="L277" title="All 4 branches missed.">        if (searchValues.isEmpty() || displayValues.isEmpty()) {</span>
          // this is a record/document that can either not be found or not be displayed
<span class="nc" id="L279">          logger.trace(</span>
              &quot;No search or display values found for feature: {} in featuretype: {}, skipped for indexing&quot;,
<span class="nc" id="L281">              feature.getID(),</span>
<span class="nc" id="L282">              tmFeatureType.getName());</span>
<span class="nc" id="L283">          indexSkippedCounter++;</span>
        } else {
<span class="nc" id="L285">          doc.setSearchFields(searchValues.toArray(new String[0]));</span>
<span class="nc" id="L286">          doc.setDisplayFields(displayValues.toArray(new String[0]));</span>
<span class="nc" id="L287">          docsBatch.add(doc);</span>
        }

<span class="nc bnc" id="L290" title="All 2 branches missed.">        if (indexCounter % solrBatchSize == 0) {</span>
<span class="nc" id="L291">          updateResponse = solrClient.addBeans(docsBatch, solrQueryTimeout);</span>
<span class="nc" id="L292">          logger.info(</span>
              &quot;Added {} documents of {} to index, result status: {}&quot;,
<span class="nc" id="L294">              indexCounter - indexSkippedCounter,</span>
<span class="nc" id="L295">              total,</span>
<span class="nc" id="L296">              updateResponse.getStatus());</span>
<span class="nc" id="L297">          docsBatch.clear();</span>
        }
<span class="nc" id="L299">      }</span>
    } finally {
<span class="nc bnc" id="L301" title="All 2 branches missed.">      if (fs.getDataStore() != null) fs.getDataStore().dispose();</span>
    }

<span class="nc bnc" id="L304" title="All 2 branches missed.">    if (!docsBatch.isEmpty()) {</span>
<span class="nc" id="L305">      solrClient.addBeans(docsBatch, solrQueryTimeout);</span>
<span class="nc" id="L306">      logger.info(&quot;Added last {} documents of {} to index&quot;, docsBatch.size(), total);</span>
    }
<span class="nc" id="L308">    final Instant finishedAt = Instant.now();</span>
<span class="nc" id="L309">    Duration processTime = Duration.between(startedAt, finishedAt).abs();</span>
<span class="nc" id="L310">    logger.info(</span>
        &quot;Indexing finished for index id: {}, featuretype: {} at {} in {}&quot;,
<span class="nc" id="L312">        searchIndex.getId(),</span>
<span class="nc" id="L313">        tmFeatureType.getName(),</span>
        finishedAt,
        processTime);
<span class="nc" id="L316">    updateResponse = this.solrClient.commit();</span>
<span class="nc" id="L317">    logger.debug(&quot;Update response commit status: {}&quot;, updateResponse.getStatus());</span>

<span class="nc bnc" id="L319" title="All 2 branches missed.">    if (indexSkippedCounter &gt; 0) {</span>
<span class="nc" id="L320">      logger.warn(</span>
          &quot;{} features were skipped because no search or display values were found.&quot;,
<span class="nc" id="L322">          indexSkippedCounter);</span>
<span class="nc" id="L323">      searchIndex =</span>
<span class="nc" id="L324">          searchIndex.setComment(</span>
              &quot;Indexed %s features in %s.%s seconds, started at %s. %s features were skipped because no search or display values were found.&quot;
<span class="nc" id="L326">                  .formatted(</span>
<span class="nc" id="L327">                      total,</span>
<span class="nc" id="L328">                      processTime.getSeconds(),</span>
<span class="nc" id="L329">                      processTime.getNano(),</span>
                      startedAt,
<span class="nc" id="L331">                      indexSkippedCounter));</span>
    } else {
<span class="nc" id="L333">      searchIndex =</span>
<span class="nc" id="L334">          searchIndex.setComment(</span>
              &quot;Indexed %s features in %s.%s seconds, started at %s.&quot;
<span class="nc" id="L336">                  .formatted(total, processTime.getSeconds(), processTime.getNano(), startedAt));</span>
    }

<span class="nc" id="L339">    return searchIndexRepository.save(</span>
        searchIndex
<span class="nc" id="L341">            .setLastIndexed(</span>
<span class="nc" id="L342">                finishedAt.atOffset(ZoneId.systemDefault().getRules().getOffset(finishedAt)))</span>
<span class="nc" id="L343">            .setStatus(SearchIndex.Status.INDEXED));</span>
  }

  /**
   * Clear the index for a layer.
   *
   * @param searchLayerId the layer id
   * @throws IOException if an I/O error occurs
   * @throws SolrServerException if a Solr error occurs
   */
  public void clearIndexForLayer(@NotNull Long searchLayerId)
      throws IOException, SolrServerException {

<span class="nc" id="L356">    QueryResponse response =</span>
<span class="nc" id="L357">        solrClient.query(</span>
            new SolrQuery(&quot;exists(query(&quot; + SEARCH_LAYER + &quot;:&quot; + searchLayerId + &quot;))&quot;));
<span class="nc bnc" id="L359" title="All 2 branches missed.">    if (response.getResults().getNumFound() &gt; 0) {</span>
<span class="nc" id="L360">      logger.info(&quot;Clearing index for searchLayer {}&quot;, searchLayerId);</span>
<span class="nc" id="L361">      UpdateResponse updateResponse = solrClient.deleteByQuery(SEARCH_LAYER + &quot;:&quot; + searchLayerId);</span>
<span class="nc" id="L362">      logger.debug(&quot;Delete response status: {}&quot;, updateResponse.getStatus());</span>
<span class="nc" id="L363">      updateResponse = solrClient.commit();</span>
<span class="nc" id="L364">      logger.debug(&quot;Commit response status: {}&quot;, updateResponse.getStatus());</span>
<span class="nc" id="L365">    } else {</span>
<span class="nc" id="L366">      logger.info(&quot;No index to clear for layer {}&quot;, searchLayerId);</span>
    }
<span class="nc" id="L368">  }</span>

  /**
   * Search in the index for a layer. The given query is augmented to filter on the {@code
   * solrLayerId}.
   *
   * @param searchIndex the search index
   * @param solrQuery the query, when {@code null} or empty, the query is set to {@code *} (match
   *     all)
   * @param solrPoint the point to search around, in (x y) format
   * @param solrDistance the distance to search around the point in Solr distance units (kilometers)
   * @param start the start index, starting at 0
   * @param numResultsToReturn the number of results to return
   * @return the documents
   * @throws IOException if an I/O error occurs
   * @throws SolrServerException if a Solr error occurs
   */
  public SearchResponse findInIndex(
      @NotNull SearchIndex searchIndex,
      String solrQuery,
      String solrFilterQuery,
      String solrPoint,
      Double solrDistance,
      int start,
      int numResultsToReturn)
      throws IOException, SolrServerException, SolrException {

<span class="nc" id="L395">    logger.info(&quot;Find in index for {}&quot;, searchIndex.getId());</span>
<span class="nc bnc" id="L396" title="All 4 branches missed.">    if (null == solrQuery || solrQuery.isBlank()) {</span>
<span class="nc" id="L397">      solrQuery = &quot;*&quot;;</span>
    }
    // TODO We could escape special/syntax characters, but that also prevents using
    //      keys like ~ and *
    // solrQuery = ClientUtils.escapeQueryChars(solrQuery);

<span class="nc" id="L403">    final SolrQuery query =</span>
        new SolrQuery(INDEX_SEARCH_FIELD + &quot;:&quot; + solrQuery)
<span class="nc" id="L405">            .setShowDebugInfo(logger.isDebugEnabled())</span>
<span class="nc" id="L406">            .setTimeAllowed(solrQueryTimeout)</span>
<span class="nc" id="L407">            .setIncludeScore(true)</span>
<span class="nc" id="L408">            .setFields(SEARCH_ID_FIELD, INDEX_DISPLAY_FIELD, INDEX_GEOM_FIELD)</span>
<span class="nc" id="L409">            .addFilterQuery(SEARCH_LAYER + &quot;:&quot; + searchIndex.getId())</span>
<span class="nc" id="L410">            .setSort(&quot;score&quot;, SolrQuery.ORDER.desc)</span>
<span class="nc" id="L411">            .addSort(SEARCH_ID_FIELD, SolrQuery.ORDER.asc)</span>
<span class="nc" id="L412">            .setRows(numResultsToReturn)</span>
<span class="nc" id="L413">            .setStart(start);</span>

<span class="nc bnc" id="L415" title="All 4 branches missed.">    if (null != solrFilterQuery &amp;&amp; !solrFilterQuery.isBlank()) {</span>
<span class="nc" id="L416">      query.addFilterQuery(solrFilterQuery);</span>
    }
<span class="nc bnc" id="L418" title="All 4 branches missed.">    if (null != solrPoint &amp;&amp; null != solrDistance) {</span>
<span class="nc bnc" id="L419" title="All 2 branches missed.">      if (null == solrFilterQuery</span>
<span class="nc bnc" id="L420" title="All 4 branches missed.">          || !(solrFilterQuery.startsWith(&quot;{!geofilt&quot;) || solrFilterQuery.startsWith(&quot;{!bbox&quot;))) {</span>
<span class="nc" id="L421">        query.addFilterQuery(&quot;{!geofilt sfield=&quot; + INDEX_GEOM_FIELD + &quot;}&quot;);</span>
      }
<span class="nc" id="L423">      query.add(&quot;pt&quot;, solrPoint);</span>
<span class="nc" id="L424">      query.add(&quot;d&quot;, solrDistance.toString());</span>
    }
<span class="nc" id="L426">    query.set(&quot;q.op&quot;, &quot;AND&quot;);</span>
<span class="nc" id="L427">    logger.debug(&quot;Solr query: {}&quot;, query);</span>

<span class="nc" id="L429">    final QueryResponse response = solrClient.query(query);</span>
<span class="nc" id="L430">    logger.debug(&quot;response: {}&quot;, response);</span>

<span class="nc" id="L432">    final SolrDocumentList solrDocumentList = response.getResults();</span>
<span class="nc" id="L433">    logger.debug(&quot;Found {} solr documents&quot;, solrDocumentList.getNumFound());</span>
<span class="nc" id="L434">    final SearchResponse searchResponse =</span>
        new SearchResponse()
<span class="nc" id="L436">            .total(solrDocumentList.getNumFound())</span>
<span class="nc" id="L437">            .start(response.getResults().getStart())</span>
<span class="nc" id="L438">            .maxScore(solrDocumentList.getMaxScore());</span>
<span class="nc" id="L439">    response</span>
<span class="nc" id="L440">        .getResults()</span>
<span class="nc" id="L441">        .forEach(</span>
            solrDocument -&gt; {
<span class="nc" id="L443">              List&lt;String&gt; displayValues =</span>
<span class="nc" id="L444">                  solrDocument.getFieldValues(INDEX_DISPLAY_FIELD).stream()</span>
<span class="nc" id="L445">                      .map(Object::toString)</span>
<span class="nc" id="L446">                      .toList();</span>
<span class="nc" id="L447">              searchResponse.addDocumentsItem(</span>
                  new SearchDocument()
<span class="nc" id="L449">                      .fid(solrDocument.getFieldValue(SEARCH_ID_FIELD).toString())</span>
<span class="nc" id="L450">                      .geometry(solrDocument.getFieldValue(INDEX_GEOM_FIELD).toString())</span>
<span class="nc" id="L451">                      .displayValues(displayValues));</span>
<span class="nc" id="L452">            });</span>

<span class="nc" id="L454">    return searchResponse;</span>
  }

  /**
   * Close the wrapped Solr client.
   *
   * @throws IOException if an I/O error occurs
   */
  @Override
  public void close() throws IOException {
<span class="nc bnc" id="L464" title="All 2 branches missed.">    if (null != this.solrClient) this.solrClient.close();</span>
<span class="nc" id="L465">  }</span>

  private boolean checkSchemaIfFieldExists(String fieldName) {
<span class="nc" id="L468">    SchemaRequest.Field fieldCheck = new SchemaRequest.Field(fieldName);</span>
    try {
<span class="nc" id="L470">      SchemaResponse.FieldResponse isField = fieldCheck.process(solrClient);</span>
<span class="nc" id="L471">      logger.debug(&quot;Field {} exists&quot;, isField.getField());</span>
<span class="nc" id="L472">      return true;</span>
<span class="nc" id="L473">    } catch (SolrServerException | BaseHttpSolrClient.RemoteSolrException e) {</span>
<span class="nc" id="L474">      logger.debug(</span>
          &quot;Field {} does not exist or could not be retrieved. Assuming it does not exist.&quot;,
          fieldName);
<span class="nc" id="L477">    } catch (IOException e) {</span>
<span class="nc" id="L478">      logger.error(&quot;Tried getting field: {}, but failed.&quot;, fieldName, e);</span>
<span class="nc" id="L479">    }</span>
<span class="nc" id="L480">    return false;</span>
  }

  /**
   * @param fieldName the name of the field to create
   * @throws SolrServerException if a Solr error occurs
   * @throws IOException if an I/O error occurs
   */
  private void createSchemaFieldIfNotExists(String fieldName)
      throws SolrServerException, IOException {
<span class="nc bnc" id="L490" title="All 2 branches missed.">    if (!checkSchemaIfFieldExists(fieldName)) {</span>
<span class="nc" id="L491">      logger.info(&quot;Creating Solr field {}.&quot;, fieldName);</span>
<span class="nc" id="L492">      SchemaRequest.AddField schemaRequest = solrSearchFields.get(fieldName);</span>
<span class="nc" id="L493">      SolrResponse response = schemaRequest.process(solrClient);</span>
<span class="nc" id="L494">      logger.debug(&quot;Field type {} created&quot;, response);</span>
<span class="nc" id="L495">      solrClient.commit();</span>
    }
<span class="nc" id="L497">  }</span>

  /** Programmatically create the schema if it does not exist. */
  private void createSchemaIfNotExists() {
<span class="nc" id="L501">    solrSearchFields.forEach(</span>
        (key, value) -&gt; {
          try {
<span class="nc bnc" id="L504" title="All 2 branches missed.">            if (key.equals(INDEX_GEOM_FIELD)) {</span>
<span class="nc" id="L505">              createGeometryFieldTypeIfNotExists();</span>
            }
<span class="nc" id="L507">            createSchemaFieldIfNotExists(key);</span>
<span class="nc" id="L508">          } catch (SolrServerException | IOException e) {</span>
<span class="nc" id="L509">            logger.error(</span>
                &quot;Error creating schema field: {} indexing may fail. Details: {}&quot;,
                key,
<span class="nc" id="L512">                e.getLocalizedMessage(),</span>
                e);
<span class="nc" id="L514">          }</span>
<span class="nc" id="L515">        });</span>
<span class="nc" id="L516">  }</span>

  private void createGeometryFieldTypeIfNotExists() throws SolrServerException, IOException {
<span class="nc" id="L519">    SchemaRequest.FieldType fieldTypeCheck = new SchemaRequest.FieldType(SOLR_SPATIAL_FIELDNAME);</span>
    try {
<span class="nc" id="L521">      SchemaResponse.FieldTypeResponse isFieldType = fieldTypeCheck.process(solrClient);</span>
<span class="nc" id="L522">      logger.debug(&quot;Field type {} exists&quot;, isFieldType.getFieldType());</span>
<span class="nc" id="L523">      return;</span>
<span class="nc" id="L524">    } catch (SolrServerException | BaseHttpSolrClient.RemoteSolrException e) {</span>
<span class="nc" id="L525">      logger.debug(</span>
          &quot;Field type {} does not exist or could not be retrieved. Assuming it does not exist.&quot;,
          SOLR_SPATIAL_FIELDNAME);
<span class="nc" id="L528">    } catch (IOException e) {</span>
<span class="nc" id="L529">      logger.error(&quot;Tried getting field type: {}, but failed.&quot;, SOLR_SPATIAL_FIELDNAME, e);</span>
<span class="nc" id="L530">    }</span>

<span class="nc" id="L532">    logger.info(</span>
        &quot;Creating Solr field type for {} with validation rule {}&quot;,
        SOLR_SPATIAL_FIELDNAME,
        solrGeometryValidationRule);
<span class="nc" id="L536">    FieldTypeDefinition spatialFieldTypeDef = new FieldTypeDefinition();</span>
<span class="nc" id="L537">    Map&lt;String, Object&gt; spatialFieldAttributes =</span>
        new HashMap&lt;&gt;(
<span class="nc" id="L539">            Map.of(</span>
                &quot;name&quot;, SOLR_SPATIAL_FIELDNAME,
                &quot;class&quot;, &quot;solr.SpatialRecursivePrefixTreeFieldType&quot;,
                &quot;spatialContextFactory&quot;, &quot;JTS&quot;,
<span class="nc" id="L543">                &quot;geo&quot;, false,</span>
                &quot;distanceUnits&quot;, &quot;kilometers&quot;,
                &quot;distCalculator&quot;, &quot;cartesian&quot;,
                &quot;format&quot;, &quot;WKT&quot;,
<span class="nc" id="L547">                &quot;autoIndex&quot;, true,</span>
                &quot;distErrPct&quot;, &quot;0.025&quot;,
                &quot;maxDistErr&quot;, &quot;0.001&quot;));
<span class="nc" id="L550">    spatialFieldAttributes.putAll(</span>
<span class="nc" id="L551">        Map.of(</span>
            &quot;prefixTree&quot;,
            &quot;packedQuad&quot;,
            // see
            // https://locationtech.github.io/spatial4j/apidocs/org/locationtech/spatial4j/context/jts/ValidationRule.html
            &quot;validationRule&quot;,
            this.solrGeometryValidationRule,
            // NOTE THE ODDITY in coordinate order of &quot;worldBounds&quot;,
            // &quot;ENVELOPE(minX, maxX, maxY, minY)&quot;
            &quot;worldBounds&quot;,
            // webmercator / EPSG:3857 projected bounds
            &quot;ENVELOPE(-20037508.34, 20037508.34, 20048966.1, -20048966.1)&quot;
            // Amersfoort/RD new / EPSG:28992 projected bounds
            // &quot;ENVELOPE(482.06, 284182.97, 637049.52, 306602.42)&quot;
            ));
<span class="nc" id="L566">    spatialFieldTypeDef.setAttributes(spatialFieldAttributes);</span>
<span class="nc" id="L567">    SchemaRequest.AddFieldType spatialFieldType =</span>
        new SchemaRequest.AddFieldType(spatialFieldTypeDef);
<span class="nc" id="L569">    spatialFieldType.process(solrClient);</span>
<span class="nc" id="L570">    solrClient.commit();</span>
<span class="nc" id="L571">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>