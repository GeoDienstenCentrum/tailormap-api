<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SolrHelper.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Aggregate Test Coverage</a> &gt; <a href="index.source.html" class="el_package">org.tailormap.api.solr</a> &gt; <span class="el_source">SolrHelper.java</span></div><h1>SolrHelper.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2024 B3Partners B.V.
 *
 * SPDX-License-Identifier: MIT
 */
package org.tailormap.api.solr;

import jakarta.validation.constraints.NotNull;
import java.io.IOException;
import java.lang.invoke.MethodHandles;
import java.time.Duration;
import java.time.Instant;
import java.time.ZoneId;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.apache.solr.client.solrj.SolrClient;
import org.apache.solr.client.solrj.SolrQuery;
import org.apache.solr.client.solrj.SolrResponse;
import org.apache.solr.client.solrj.SolrServerException;
import org.apache.solr.client.solrj.impl.BaseHttpSolrClient;
import org.apache.solr.client.solrj.request.schema.FieldTypeDefinition;
import org.apache.solr.client.solrj.request.schema.SchemaRequest;
import org.apache.solr.client.solrj.response.QueryResponse;
import org.apache.solr.client.solrj.response.UpdateResponse;
import org.apache.solr.client.solrj.response.schema.SchemaResponse;
import org.apache.solr.common.SolrDocumentList;
import org.apache.solr.common.SolrException;
import org.geotools.api.data.Query;
import org.geotools.api.data.SimpleFeatureSource;
import org.geotools.api.feature.simple.SimpleFeature;
import org.geotools.data.simple.SimpleFeatureCollection;
import org.geotools.data.simple.SimpleFeatureIterator;
import org.locationtech.jts.geom.Geometry;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.tailormap.api.geotools.featuresources.FeatureSourceFactoryHelper;
import org.tailormap.api.geotools.processing.GeometryProcessor;
import org.tailormap.api.persistence.SearchIndex;
import org.tailormap.api.persistence.TMFeatureType;
import org.tailormap.api.repository.SearchIndexRepository;
import org.tailormap.api.util.Constants;
import org.tailormap.api.viewer.model.SearchDocument;
import org.tailormap.api.viewer.model.SearchResponse;

/**
 * Solr utility/wrapper class. This class provides methods to add or update a full-text feature type
 * index for a layer, find in the index for a layer, and clear the index for a layer. It also
 * provides a method to close the Solr client as well as automatically closing the client when used
 * in a try-with-resources.
 */
public class SolrHelper implements AutoCloseable, Constants {
  /**
   * the number of documents that are submitted per batch to the Solr service: {@value
   * #SOLR_BATCH_SIZE}.
   */
  public static final int SOLR_BATCH_SIZE = 1000;

<span class="nc" id="L62">  private static final Logger logger =</span>
<span class="nc" id="L63">      LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());</span>

  /** {@value #SOLR_TIMEOUT} milliseconds. */
  private static final int SOLR_TIMEOUT = 7000;

  /** the Solr field type name geometry fields: {@value #SOLR_SPATIAL_FIELDNAME}. */
  private static final String SOLR_SPATIAL_FIELDNAME = &quot;tm_geometry_rpt&quot;;

  private final SolrClient solrClient;

  /** the Solr search field definition requests for Tailormap. */
<span class="nc" id="L74">  private final Map&lt;String, SchemaRequest.AddField&gt; solrSearchFields =</span>
<span class="nc" id="L75">      Map.of(</span>
          SEARCH_LAYER,
              new SchemaRequest.AddField(
<span class="nc" id="L78">                  Map.of(</span>
                      &quot;name&quot;, SEARCH_LAYER,
                      &quot;type&quot;, &quot;string&quot;,
<span class="nc" id="L81">                      &quot;indexed&quot;, true,</span>
<span class="nc" id="L82">                      &quot;stored&quot;, true,</span>
<span class="nc" id="L83">                      &quot;multiValued&quot;, false,</span>
<span class="nc" id="L84">                      &quot;required&quot;, true,</span>
<span class="nc" id="L85">                      &quot;uninvertible&quot;, false)),</span>
          INDEX_GEOM_FIELD,
              new SchemaRequest.AddField(
<span class="nc" id="L88">                  Map.of(&quot;name&quot;, INDEX_GEOM_FIELD, &quot;type&quot;, SOLR_SPATIAL_FIELDNAME, &quot;stored&quot;, true)),</span>
          INDEX_SEARCH_FIELD,
              new SchemaRequest.AddField(
<span class="nc" id="L91">                  Map.of(</span>
                      &quot;name&quot;, INDEX_SEARCH_FIELD,
                      &quot;type&quot;, &quot;text_general&quot;,
<span class="nc" id="L94">                      &quot;indexed&quot;, true,</span>
<span class="nc" id="L95">                      &quot;stored&quot;, true,</span>
<span class="nc" id="L96">                      &quot;multiValued&quot;, true,</span>
<span class="nc" id="L97">                      &quot;required&quot;, true,</span>
<span class="nc" id="L98">                      &quot;uninvertible&quot;, false)),</span>
          INDEX_DISPLAY_FIELD,
              new SchemaRequest.AddField(
<span class="nc" id="L101">                  Map.of(</span>
                      &quot;name&quot;, INDEX_DISPLAY_FIELD,
                      &quot;type&quot;, &quot;text_general&quot;,
<span class="nc" id="L104">                      &quot;indexed&quot;, false,</span>
<span class="nc" id="L105">                      &quot;stored&quot;, true,</span>
<span class="nc" id="L106">                      &quot;multiValued&quot;, true,</span>
<span class="nc" id="L107">                      &quot;required&quot;, true,</span>
<span class="nc" id="L108">                      &quot;uninvertible&quot;, false)));</span>

  /**
   * Constructor
   *
   * @param solrClient the Solr client, this will be closed when this class is closed
   */
<span class="nc" id="L115">  public SolrHelper(@NotNull SolrClient solrClient) {</span>
<span class="nc" id="L116">    this.solrClient = solrClient;</span>
<span class="nc" id="L117">  }</span>

  /**
   * Add or update a feature type index for a layer.
   *
   * @param searchIndex the search index config
   * @param tmFeatureType the feature type
   * @param featureSourceFactoryHelper the feature source factory helper
   * @param searchIndexRepository the search index repository, so we can save the {@code
   *     searchIndex}
   * @throws IOException if an I/O error occurs
   * @throws SolrServerException if a Solr error occurs
   * @return the possibly updated {@code searchIndex} object
   */
  @SuppressWarnings(&quot;FromTemporalAccessor&quot;)
  public SearchIndex addFeatureTypeIndex(
      @NotNull SearchIndex searchIndex,
      @NotNull TMFeatureType tmFeatureType,
      @NotNull FeatureSourceFactoryHelper featureSourceFactoryHelper,
      @NotNull SearchIndexRepository searchIndexRepository)
      throws IOException, SolrServerException {

<span class="nc" id="L139">    createSchemaIfNotExists();</span>

<span class="nc" id="L141">    final Instant startedAt = Instant.now();</span>

<span class="nc bnc" id="L143" title="All 2 branches missed.">    if (null == searchIndex.getSearchFieldsUsed()) {</span>
<span class="nc" id="L144">      logger.warn(</span>
<span class="nc" id="L145">          &quot;No search fields configured for search index: {}, bailing out.&quot;, searchIndex.getName());</span>
<span class="nc" id="L146">      return searchIndexRepository.save(</span>
          searchIndex
<span class="nc" id="L148">              .setStatus(SearchIndex.Status.ERROR)</span>
<span class="nc" id="L149">              .setComment(&quot;No search fields configured&quot;));</span>
    }

    // set fields while filtering out hidden fields
<span class="nc" id="L153">    List&lt;String&gt; searchFields =</span>
<span class="nc" id="L154">        searchIndex.getSearchFieldsUsed().stream()</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">            .filter(s -&gt; !tmFeatureType.getSettings().getHideAttributes().contains(s))</span>
<span class="nc" id="L156">            .toList();</span>
<span class="nc" id="L157">    List&lt;String&gt; displayFields =</span>
<span class="nc" id="L158">        searchIndex.getSearchDisplayFieldsUsed().stream()</span>
<span class="nc bnc" id="L159" title="All 2 branches missed.">            .filter(s -&gt; !tmFeatureType.getSettings().getHideAttributes().contains(s))</span>
<span class="nc" id="L160">            .toList();</span>

<span class="nc bnc" id="L162" title="All 2 branches missed.">    if (searchFields.isEmpty()) {</span>
<span class="nc" id="L163">      logger.warn(</span>
          &quot;No valid search fields configured for featuretype: {}, bailing out.&quot;,
<span class="nc" id="L165">          tmFeatureType.getName());</span>
<span class="nc" id="L166">      return searchIndexRepository.save(</span>
          searchIndex
<span class="nc" id="L168">              .setStatus(SearchIndex.Status.ERROR)</span>
<span class="nc" id="L169">              .setComment(&quot;No search fields configured&quot;));</span>
    }

    // add search and display properties to query
<span class="nc" id="L173">    Set&lt;String&gt; propertyNames = new HashSet&lt;&gt;();</span>
    // always add primary key and default geometry to geotools query
<span class="nc" id="L175">    propertyNames.add(tmFeatureType.getPrimaryKeyAttribute());</span>
<span class="nc" id="L176">    propertyNames.add(tmFeatureType.getDefaultGeometryAttribute());</span>
<span class="nc" id="L177">    propertyNames.addAll(searchFields);</span>

<span class="nc bnc" id="L179" title="All 2 branches missed.">    if (!displayFields.isEmpty()) {</span>
<span class="nc" id="L180">      propertyNames.addAll(displayFields);</span>
    }

<span class="nc" id="L183">    clearIndexForLayer(searchIndex.getId());</span>

<span class="nc" id="L185">    logger.info(</span>
        &quot;Indexing started for index id: {}, feature type: {}&quot;,
<span class="nc" id="L187">        searchIndex.getId(),</span>
<span class="nc" id="L188">        tmFeatureType.getName());</span>
<span class="nc" id="L189">    searchIndex = searchIndexRepository.save(searchIndex.setStatus(SearchIndex.Status.INDEXING));</span>

    // collect features to index
<span class="nc" id="L192">    SimpleFeatureSource fs = featureSourceFactoryHelper.openGeoToolsFeatureSource(tmFeatureType);</span>
<span class="nc" id="L193">    Query q = new Query(fs.getName().toString());</span>
    // filter out any hidden properties (there should be none though)
<span class="nc" id="L195">    tmFeatureType.getSettings().getHideAttributes().forEach(propertyNames::remove);</span>
<span class="nc" id="L196">    q.setPropertyNames(List.copyOf(propertyNames));</span>
<span class="nc" id="L197">    q.setStartIndex(0);</span>
    // TODO: make maxFeatures configurable?
    // q.setMaxFeatures(Integer.MAX_VALUE);
<span class="nc" id="L200">    logger.trace(&quot;Indexing query: {}&quot;, q);</span>
<span class="nc" id="L201">    SimpleFeatureCollection simpleFeatureCollection = fs.getFeatures(q);</span>
<span class="nc" id="L202">    final int total = simpleFeatureCollection.size();</span>
<span class="nc" id="L203">    List&lt;FeatureIndexingDocument&gt; docsBatch = new ArrayList&lt;&gt;(SOLR_BATCH_SIZE);</span>
    // TODO this does not currently batch/page the feature source query, this doesn't seem to be an
    //   issue for now but could be if the feature source is very, very large or slow
    UpdateResponse updateResponse;
<span class="nc" id="L207">    int indexCounter = 0;</span>
<span class="nc" id="L208">    int indexSkippedCounter = 0;</span>
<span class="nc" id="L209">    try (SimpleFeatureIterator iterator = simpleFeatureCollection.features()) {</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">      while (iterator.hasNext()) {</span>
<span class="nc" id="L211">        indexCounter++;</span>
<span class="nc" id="L212">        SimpleFeature feature = iterator.next();</span>
        // note that this will create a unique document
<span class="nc" id="L214">        FeatureIndexingDocument doc =</span>
<span class="nc" id="L215">            new FeatureIndexingDocument(feature.getID(), searchIndex.getId());</span>
<span class="nc" id="L216">        List&lt;String&gt; searchValues = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L217">        List&lt;String&gt; displayValues = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L218">        propertyNames.forEach(</span>
            propertyName -&gt; {
<span class="nc" id="L220">              Object value = feature.getAttribute(propertyName);</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">              if (value != null) {</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">                if (value instanceof Geometry</span>
<span class="nc bnc" id="L223" title="All 2 branches missed.">                    &amp;&amp; propertyName.equals(tmFeatureType.getDefaultGeometryAttribute())) {</span>
                  // We could use GeoJSON, but WKT is more compact and that would also incur a
                  // change to the API
<span class="nc" id="L226">                  doc.setGeometry(GeometryProcessor.processGeometry(value, true, true, null));</span>
                } else {
<span class="nc bnc" id="L228" title="All 2 branches missed.">                  if (searchFields.contains(propertyName)) {</span>
<span class="nc" id="L229">                    searchValues.add(value.toString());</span>
                  }
<span class="nc bnc" id="L231" title="All 2 branches missed.">                  if (displayFields.contains(propertyName)) {</span>
<span class="nc" id="L232">                    displayValues.add(value.toString());</span>
                  }
                }
              }
<span class="nc" id="L236">            });</span>
<span class="nc bnc" id="L237" title="All 4 branches missed.">        if (searchValues.isEmpty() || displayValues.isEmpty()) {</span>
          // this is a record/document that can either not be found or not be displayed
<span class="nc" id="L239">          logger.trace(</span>
              &quot;No search or display values found for feature: {} in featuretype: {}, skipped for indexing&quot;,
<span class="nc" id="L241">              feature.getID(),</span>
<span class="nc" id="L242">              tmFeatureType.getName());</span>
<span class="nc" id="L243">          indexSkippedCounter++;</span>
        } else {
<span class="nc" id="L245">          doc.setSearchFields(searchValues.toArray(new String[0]));</span>
<span class="nc" id="L246">          doc.setDisplayFields(displayValues.toArray(new String[0]));</span>
<span class="nc" id="L247">          docsBatch.add(doc);</span>
        }

<span class="nc bnc" id="L250" title="All 2 branches missed.">        if (indexCounter % SOLR_BATCH_SIZE == 0) {</span>
<span class="nc" id="L251">          updateResponse = solrClient.addBeans(docsBatch);</span>
<span class="nc" id="L252">          logger.info(</span>
              &quot;Added {} documents of {} to index, result status: {}&quot;,
<span class="nc" id="L254">              indexCounter - indexSkippedCounter,</span>
<span class="nc" id="L255">              total,</span>
<span class="nc" id="L256">              updateResponse.getStatus());</span>
<span class="nc" id="L257">          docsBatch.clear();</span>
        }
<span class="nc" id="L259">      }</span>
    } finally {
<span class="nc bnc" id="L261" title="All 2 branches missed.">      if (fs.getDataStore() != null) fs.getDataStore().dispose();</span>
    }

<span class="nc bnc" id="L264" title="All 2 branches missed.">    if (!docsBatch.isEmpty()) {</span>
<span class="nc" id="L265">      solrClient.addBeans(docsBatch);</span>
<span class="nc" id="L266">      logger.info(&quot;Added last {} documents of {} to index&quot;, docsBatch.size(), total);</span>
    }
<span class="nc" id="L268">    final Instant finishedAt = Instant.now();</span>
<span class="nc" id="L269">    Duration processTime = Duration.between(startedAt, finishedAt).abs();</span>
<span class="nc" id="L270">    logger.info(</span>
        &quot;Indexing finished for index id: {}, featuretype: {} at {} in {}&quot;,
<span class="nc" id="L272">        searchIndex.getId(),</span>
<span class="nc" id="L273">        tmFeatureType.getName(),</span>
        finishedAt,
        processTime);
<span class="nc" id="L276">    updateResponse = this.solrClient.commit();</span>
<span class="nc" id="L277">    logger.debug(&quot;Update response commit status: {}&quot;, updateResponse.getStatus());</span>

<span class="nc bnc" id="L279" title="All 2 branches missed.">    if (indexSkippedCounter &gt; 0) {</span>
<span class="nc" id="L280">      logger.warn(</span>
          &quot;{} features were skipped because no search or display values were found.&quot;,
<span class="nc" id="L282">          indexSkippedCounter);</span>
<span class="nc" id="L283">      searchIndex =</span>
<span class="nc" id="L284">          searchIndex.setComment(</span>
              &quot;Indexed %s features in %s.%s seconds, started at %s. %s features were skipped because no search or display values were found.&quot;
<span class="nc" id="L286">                  .formatted(</span>
<span class="nc" id="L287">                      total,</span>
<span class="nc" id="L288">                      processTime.getSeconds(),</span>
<span class="nc" id="L289">                      processTime.getNano(),</span>
                      startedAt,
<span class="nc" id="L291">                      indexSkippedCounter));</span>
    } else {
<span class="nc" id="L293">      searchIndex =</span>
<span class="nc" id="L294">          searchIndex.setComment(</span>
              &quot;Indexed %s features in %s.%s seconds, started at %s.&quot;
<span class="nc" id="L296">                  .formatted(total, processTime.getSeconds(), processTime.getNano(), startedAt));</span>
    }

<span class="nc" id="L299">    return searchIndexRepository.save(</span>
        searchIndex
<span class="nc" id="L301">            .setLastIndexed(</span>
<span class="nc" id="L302">                finishedAt.atOffset(ZoneId.systemDefault().getRules().getOffset(finishedAt)))</span>
<span class="nc" id="L303">            .setStatus(SearchIndex.Status.INDEXED));</span>
  }

  /**
   * Clear the index for a layer.
   *
   * @param searchLayerId the layer id
   * @throws IOException if an I/O error occurs
   * @throws SolrServerException if a Solr error occurs
   */
  public void clearIndexForLayer(@NotNull Long searchLayerId)
      throws IOException, SolrServerException {
<span class="nc" id="L315">    QueryResponse response =</span>
<span class="nc" id="L316">        solrClient.query(</span>
            new SolrQuery(&quot;exists(query(&quot; + SEARCH_LAYER + &quot;:&quot; + searchLayerId + &quot;))&quot;));
<span class="nc bnc" id="L318" title="All 2 branches missed.">    if (response.getResults().getNumFound() &gt; 0) {</span>
<span class="nc" id="L319">      logger.info(&quot;Clearing index for searchLayer {}&quot;, searchLayerId);</span>
<span class="nc" id="L320">      UpdateResponse updateResponse = solrClient.deleteByQuery(SEARCH_LAYER + &quot;:&quot; + searchLayerId);</span>
<span class="nc" id="L321">      logger.debug(&quot;Delete response status: {}&quot;, updateResponse.getStatus());</span>
<span class="nc" id="L322">      updateResponse = solrClient.commit();</span>
<span class="nc" id="L323">      logger.debug(&quot;Commit response status: {}&quot;, updateResponse.getStatus());</span>
<span class="nc" id="L324">    } else {</span>
<span class="nc" id="L325">      logger.info(&quot;No index to clear for layer {}&quot;, searchLayerId);</span>
    }
<span class="nc" id="L327">  }</span>

  /**
   * Search in the index for a layer. The given query is augmented to filter on the {@code
   * solrLayerId}.
   *
   * @param searchIndex the search index
   * @param solrQuery the query, when {@code null} or empty, the query is set to {@code *} (match
   *     all)
   * @param solrPoint the point to search around, in (x y) format
   * @param solrDistance the distance to search around the point in Solr distance units (kilometers)
   * @param start the start index, starting at 0
   * @param numResultsToReturn the number of results to return
   * @return the documents
   * @throws IOException if an I/O error occurs
   * @throws SolrServerException if a Solr error occurs
   */
  public SearchResponse findInIndex(
      @NotNull SearchIndex searchIndex,
      String solrQuery,
      String solrFilterQuery,
      String solrPoint,
      Double solrDistance,
      int start,
      int numResultsToReturn)
      throws IOException, SolrServerException, SolrException {

<span class="nc" id="L354">    logger.info(&quot;Find in index for {}&quot;, searchIndex.getId());</span>
<span class="nc bnc" id="L355" title="All 4 branches missed.">    if (null == solrQuery || solrQuery.isBlank()) {</span>
<span class="nc" id="L356">      solrQuery = &quot;*&quot;;</span>
    }
    // TODO We could escape special/syntax characters, but that also prevents using
    //      keys like ~ and *
    // solrQuery = ClientUtils.escapeQueryChars(solrQuery);

<span class="nc" id="L362">    final SolrQuery query =</span>
        new SolrQuery(INDEX_SEARCH_FIELD + &quot;:&quot; + solrQuery)
<span class="nc" id="L364">            .setShowDebugInfo(logger.isDebugEnabled())</span>
<span class="nc" id="L365">            .setTimeAllowed(SOLR_TIMEOUT)</span>
<span class="nc" id="L366">            .setIncludeScore(true)</span>
<span class="nc" id="L367">            .setFields(SEARCH_ID_FIELD, INDEX_DISPLAY_FIELD, INDEX_GEOM_FIELD)</span>
<span class="nc" id="L368">            .addFilterQuery(SEARCH_LAYER + &quot;:&quot; + searchIndex.getId())</span>
<span class="nc" id="L369">            .setSort(&quot;score&quot;, SolrQuery.ORDER.desc)</span>
<span class="nc" id="L370">            .addSort(SEARCH_ID_FIELD, SolrQuery.ORDER.asc)</span>
<span class="nc" id="L371">            .setRows(numResultsToReturn)</span>
<span class="nc" id="L372">            .setStart(start);</span>

<span class="nc bnc" id="L374" title="All 4 branches missed.">    if (null != solrFilterQuery &amp;&amp; !solrFilterQuery.isBlank()) {</span>
<span class="nc" id="L375">      query.addFilterQuery(solrFilterQuery);</span>
    }
<span class="nc bnc" id="L377" title="All 4 branches missed.">    if (null != solrPoint &amp;&amp; null != solrDistance) {</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">      if (null == solrFilterQuery</span>
<span class="nc bnc" id="L379" title="All 4 branches missed.">          || !(solrFilterQuery.startsWith(&quot;{!geofilt&quot;) || solrFilterQuery.startsWith(&quot;{!bbox&quot;))) {</span>
<span class="nc" id="L380">        query.addFilterQuery(&quot;{!geofilt sfield=&quot; + INDEX_GEOM_FIELD + &quot;}&quot;);</span>
      }
<span class="nc" id="L382">      query.add(&quot;pt&quot;, solrPoint);</span>
<span class="nc" id="L383">      query.add(&quot;d&quot;, solrDistance.toString());</span>
    }
<span class="nc" id="L385">    query.set(&quot;q.op&quot;, &quot;AND&quot;);</span>
<span class="nc" id="L386">    logger.debug(&quot;Solr query: {}&quot;, query);</span>

<span class="nc" id="L388">    final QueryResponse response = solrClient.query(query);</span>
<span class="nc" id="L389">    logger.debug(&quot;response: {}&quot;, response);</span>

<span class="nc" id="L391">    final SolrDocumentList solrDocumentList = response.getResults();</span>
<span class="nc" id="L392">    logger.debug(&quot;Found {} solr documents&quot;, solrDocumentList.getNumFound());</span>
<span class="nc" id="L393">    final SearchResponse searchResponse =</span>
        new SearchResponse()
<span class="nc" id="L395">            .total(solrDocumentList.getNumFound())</span>
<span class="nc" id="L396">            .start(response.getResults().getStart())</span>
<span class="nc" id="L397">            .maxScore(solrDocumentList.getMaxScore());</span>
<span class="nc" id="L398">    response</span>
<span class="nc" id="L399">        .getResults()</span>
<span class="nc" id="L400">        .forEach(</span>
            solrDocument -&gt; {
<span class="nc" id="L402">              List&lt;String&gt; displayValues =</span>
<span class="nc" id="L403">                  solrDocument.getFieldValues(INDEX_DISPLAY_FIELD).stream()</span>
<span class="nc" id="L404">                      .map(Object::toString)</span>
<span class="nc" id="L405">                      .toList();</span>
<span class="nc" id="L406">              searchResponse.addDocumentsItem(</span>
                  new SearchDocument()
<span class="nc" id="L408">                      .fid(solrDocument.getFieldValue(SEARCH_ID_FIELD).toString())</span>
<span class="nc" id="L409">                      .geometry(solrDocument.getFieldValue(INDEX_GEOM_FIELD).toString())</span>
<span class="nc" id="L410">                      .displayValues(displayValues));</span>
<span class="nc" id="L411">            });</span>

<span class="nc" id="L413">    return searchResponse;</span>
  }

  /**
   * Close the wrapped Solr client.
   *
   * @throws IOException if an I/O error occurs
   */
  @Override
  public void close() throws IOException {
<span class="nc bnc" id="L423" title="All 2 branches missed.">    if (null != this.solrClient) this.solrClient.close();</span>
<span class="nc" id="L424">  }</span>

  private boolean checkSchemaIfFieldExists(String fieldName) {
<span class="nc" id="L427">    SchemaRequest.Field fieldCheck = new SchemaRequest.Field(fieldName);</span>
    try {
<span class="nc" id="L429">      SchemaResponse.FieldResponse isField = fieldCheck.process(solrClient);</span>
<span class="nc" id="L430">      logger.debug(&quot;Field {} exists&quot;, isField.getField());</span>
<span class="nc" id="L431">      return true;</span>
<span class="nc" id="L432">    } catch (SolrServerException | BaseHttpSolrClient.RemoteSolrException e) {</span>
<span class="nc" id="L433">      logger.debug(</span>
          &quot;Field {} does not exist or could not be retrieved. Assuming it does not exist.&quot;,
          fieldName);
<span class="nc" id="L436">    } catch (IOException e) {</span>
<span class="nc" id="L437">      logger.error(&quot;Tried getting field: {}, but failed.&quot;, fieldName, e);</span>
<span class="nc" id="L438">    }</span>
<span class="nc" id="L439">    return false;</span>
  }

  /**
   * @param fieldName the name of the field to create
   * @throws SolrServerException if a Solr error occurs
   * @throws IOException if an I/O error occurs
   */
  private void createSchemaFieldIfNotExists(String fieldName)
      throws SolrServerException, IOException {
<span class="nc bnc" id="L449" title="All 2 branches missed.">    if (!checkSchemaIfFieldExists(fieldName)) {</span>
<span class="nc" id="L450">      logger.info(&quot;Creating Solr field {}.&quot;, fieldName);</span>
<span class="nc" id="L451">      SchemaRequest.AddField schemaRequest = solrSearchFields.get(fieldName);</span>
<span class="nc" id="L452">      SolrResponse response = schemaRequest.process(solrClient);</span>
<span class="nc" id="L453">      logger.debug(&quot;Field type {} created&quot;, response);</span>
<span class="nc" id="L454">      solrClient.commit();</span>
    }
<span class="nc" id="L456">  }</span>

  /** Programmatically create the schema if it does not exist. */
  private void createSchemaIfNotExists() {
<span class="nc" id="L460">    solrSearchFields.forEach(</span>
        (key, value) -&gt; {
          try {
<span class="nc bnc" id="L463" title="All 2 branches missed.">            if (key.equals(INDEX_GEOM_FIELD)) {</span>
<span class="nc" id="L464">              createGeometryFieldTypeIfNotExists();</span>
            }
<span class="nc" id="L466">            createSchemaFieldIfNotExists(key);</span>
<span class="nc" id="L467">          } catch (SolrServerException | IOException e) {</span>
<span class="nc" id="L468">            logger.error(</span>
                &quot;Error creating schema field: {} indexing may fail. Details: {}&quot;,
                key,
<span class="nc" id="L471">                e.getLocalizedMessage(),</span>
                e);
<span class="nc" id="L473">          }</span>
<span class="nc" id="L474">        });</span>
<span class="nc" id="L475">  }</span>

  private void createGeometryFieldTypeIfNotExists() throws SolrServerException, IOException {
<span class="nc" id="L478">    SchemaRequest.FieldType fieldTypeCheck = new SchemaRequest.FieldType(SOLR_SPATIAL_FIELDNAME);</span>
    try {
<span class="nc" id="L480">      SchemaResponse.FieldTypeResponse isFieldType = fieldTypeCheck.process(solrClient);</span>
<span class="nc" id="L481">      logger.debug(&quot;Field type {} exists&quot;, isFieldType.getFieldType());</span>
<span class="nc" id="L482">      return;</span>
<span class="nc" id="L483">    } catch (SolrServerException | BaseHttpSolrClient.RemoteSolrException e) {</span>
<span class="nc" id="L484">      logger.debug(</span>
          &quot;Field type {} does not exist or could not be retrieved. Assuming it does not exist.&quot;,
          SOLR_SPATIAL_FIELDNAME);
<span class="nc" id="L487">    } catch (IOException e) {</span>
<span class="nc" id="L488">      logger.error(&quot;Tried getting field type: {}, but failed.&quot;, SOLR_SPATIAL_FIELDNAME, e);</span>
<span class="nc" id="L489">    }</span>

<span class="nc" id="L491">    logger.info(&quot;Creating Solr field type for {}&quot;, SOLR_SPATIAL_FIELDNAME);</span>
    // see
    // https://solr.apache.org/guide/solr/latest/query-guide/spatial-search.html#schema-configuration-for-rpt
<span class="nc" id="L494">    FieldTypeDefinition spatialFieldTypeDef = new FieldTypeDefinition();</span>
<span class="nc" id="L495">    Map&lt;String, Object&gt; spatialFieldAttributes =</span>
        new HashMap&lt;&gt;(
<span class="nc" id="L497">            Map.of(</span>
                &quot;name&quot;, SOLR_SPATIAL_FIELDNAME,
                &quot;class&quot;, &quot;solr.SpatialRecursivePrefixTreeFieldType&quot;,
                &quot;spatialContextFactory&quot;, &quot;JTS&quot;,
<span class="nc" id="L501">                &quot;geo&quot;, false,</span>
                &quot;distanceUnits&quot;, &quot;kilometers&quot;,
                &quot;distCalculator&quot;, &quot;cartesian&quot;,
                &quot;format&quot;, &quot;WKT&quot;,
<span class="nc" id="L505">                &quot;autoIndex&quot;, true,</span>
                &quot;distErrPct&quot;, &quot;0.025&quot;,
                &quot;maxDistErr&quot;, &quot;0.001&quot;));
<span class="nc" id="L508">    spatialFieldAttributes.putAll(</span>
<span class="nc" id="L509">        Map.of(</span>
            &quot;prefixTree&quot;,
            &quot;packedQuad&quot;,
            // see
            // https://locationtech.github.io/spatial4j/apidocs/org/locationtech/spatial4j/context/jts/ValidationRule.html
            &quot;validationRule&quot;,
            &quot;repairBuffer0&quot;,
            // NOTE THE ODDITY in coordinate order of &quot;worldBounds&quot;,
            // &quot;ENVELOPE(minX, maxX, maxY, minY)&quot;
            &quot;worldBounds&quot;,
            // webmercator / EPSG:3857 projected bounds
            &quot;ENVELOPE(-20037508.34, 20037508.34, 20048966.1, -20048966.1)&quot;
            // Amersfoort/RD new / EPSG:28992 projected bounds
            // &quot;ENVELOPE(482.06, 284182.97, 637049.52, 306602.42)&quot;
            ));
<span class="nc" id="L524">    spatialFieldTypeDef.setAttributes(spatialFieldAttributes);</span>
<span class="nc" id="L525">    SchemaRequest.AddFieldType spatialFieldType =</span>
        new SchemaRequest.AddFieldType(spatialFieldTypeDef);
<span class="nc" id="L527">    spatialFieldType.process(solrClient);</span>
<span class="nc" id="L528">    solrClient.commit();</span>
<span class="nc" id="L529">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>